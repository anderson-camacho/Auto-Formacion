
# NIVEL: ADVANCED — BACKEND

## BLOQUE A — Comunicación avanzada y protocolos

---

## A1. Límites reales de REST (el punto donde empiezan los problemas serios)

---

### A1.1 Contexto histórico y técnico

REST nació para resolver un problema muy concreto:

- interoperabilidad
    
- simplicidad
    
- escalabilidad horizontal
    
- uso de HTTP como protocolo universal
    

Durante años, REST fue **suficiente** porque los sistemas:

- eran menos interactivos
    
- tenían menos usuarios concurrentes
    
- no requerían tiempo real
    
- toleraban latencias mayores
    
- no vivían en ecosistemas de microservicios masivos
    

En ese contexto:

- request → response
    
- JSON
    
- HTTP  
    funcionaban muy bien.
    

---

### A1.2 Qué problema empieza a aparecer en sistemas avanzados

En sistemas **ADVANCED**, aparecen necesidades que REST **no fue diseñado para resolver bien**:

- comunicación **continua**
    
- **eventos** en tiempo real
    
- **streams** de datos
    
- **bidireccionalidad**
    
- **latencias muy bajas**
    
- **backpressure**
    
- **altísima frecuencia** de mensajes
    
- **microservicios muy conversadores**
    
- **dispositivos conectados (IoT)**
    

Aquí REST empieza a mostrar **síntomas**, no errores evidentes.

---

### A1.3 Definición extensa: ¿qué significa que REST “no alcance”?

REST **no falla**, simplemente:

> **no es el modelo óptimo para todos los tipos de comunicación.**

REST impone:

- request/response
    
- conexión corta
    
- cliente siempre inicia
    
- servidor responde una vez
    
- overhead por request
    
- semántica centrada en recursos
    

Cuando el problema **no encaja naturalmente** en ese molde, empiezan los parches.

---

### A1.4 Modelo mental incorrecto (muy común)

> “Si REST funciona, entonces todo debería poder hacerse con REST.”

Este modelo mental lleva a:

- endpoints artificiales
    
- polling agresivo
    
- contratos forzados
    
- sobrecarga innecesaria
    
- código complejo para simular eventos
    

REST se vuelve una **limitación**, no una solución.

---

### A1.5 Modelo mental correcto (ADVANCED)

> “REST es una **opción**, no una regla universal.”

Un desarrollador advanced entiende que:

- **el problema define el protocolo**
    
- no al revés
    

Y se pregunta:

- ¿quién inicia la comunicación?
    
- ¿es sincrónica o asincrónica?
    
- ¿hay estado continuo?
    
- ¿hay eventos?
    
- ¿hay alta frecuencia?
    
- ¿hay necesidad de streaming?
    

---

### A1.6 Problemas técnicos concretos de REST a escala

#### A1.6.1 Overhead de HTTP + JSON

Cada request REST implica:

- headers
    
- serialización/deserialización JSON
    
- parsing
    
- validación
    
- creación/destrucción de contexto
    

En alto volumen:

- el costo es significativo
    
- aunque el payload sea pequeño
    

---

#### A1.6.2 Polling (el parche clásico)

Para “simular” eventos:

- el cliente pregunta cada X tiempo
    
- aunque no haya cambios
    

Consecuencias:

- desperdicio de recursos
    
- latencia artificial
    
- escalado difícil
    
- experiencia pobre
    

---

#### A1.6.3 Falta de backpressure real

REST:

- no controla bien el ritmo del cliente
    
- no negocia velocidad
    
- no puede frenar productores fácilmente
    

En sistemas con streams:

- esto rompe estabilidad
    

---

### A1.7 Ejemplo correcto (caso real conceptual)

**Caso:** sistema de monitoreo en tiempo real

- miles de eventos por minuto
    
- usuarios conectados constantemente
    
- latencia < 1 segundo
    

**Decisión correcta:**  
REST **NO** es el protocolo principal.

Se opta por:

- WebSocket
    
- gRPC streaming
    
- mensajería (según caso)
    

REST queda para:

- configuración
    
- consultas ocasionales
    
- operaciones administrativas
    

---

### A1.8 Ejemplo incorrecto (muy común)

Todo el sistema se implementa con:

- `GET /events`
    
- polling cada 500 ms
    
- filtros por timestamp
    

Resultado:

- base de datos saturada
    
- CPU alta
    
- latencia acumulada
    
- usuarios frustrados
    

---

### A1.9 Errores típicos del principiante avanzado

Aunque ya no es trainee, aparecen errores como:

- “REST siempre escala”
    
- “HTTP/2 lo arregla todo”
    
- “ponle caché”
    
- “subamos el polling interval”
    
- “metamos más servidores”
    

Son **parches**, no soluciones.

---

### A1.10 Señales de comprensión real

Sabes que entiendes este punto cuando puedes:

- explicar **qué tipo de problema NO es REST-friendly**
    
- justificar **por qué** usarías otro protocolo
    
- aceptar que REST sigue siendo útil, pero **no universal**
    
- describir el costo real del polling
    

---

### A1.11 Ejercicio práctico (obligatorio)

Toma un sistema que conozcas y responde:

1. ¿Qué partes usan REST?
    
2. ¿Cuántas llamadas por minuto generan?
    
3. ¿Hay polling?
    
4. ¿Qué pasaría si el tráfico se multiplica x10?
    
5. ¿Qué parte debería cambiar de protocolo?
    

---

## A1.12 Transición al siguiente subtema

Hasta aquí entendimos **por qué** REST deja de ser suficiente.  
Ahora entramos en **el primer protocolo alternativo clave**:

> **WebSocket**,  
> cuando el sistema necesita **conexión persistente y comunicación bidireccional real**.

---

## A2. WebSocket — Comunicación persistente y full-duplex

---

### A2.1 Contexto: por qué aparece WebSocket

WebSocket surge porque HTTP/REST **no fue diseñado** para:

- mantener conexiones abiertas
    
- enviar datos desde el servidor sin solicitud previa
    
- soportar comunicación continua
    
- manejar interacciones en tiempo real
    

Antes de WebSocket, se usaban **parches**:

- polling corto
    
- long polling
    
- Server-Sent Events (SSE)
    
- hacks con iframes o streams HTTP
    

Estos enfoques:

- consumían muchos recursos
    
- eran difíciles de escalar
    
- introducían latencia artificial
    
- complicaban el código
    

WebSocket aparece para resolver **el problema estructural**, no el síntoma.

---

### A2.2 Definición extensa y desarmada de WebSocket

WebSocket es:

> **Un protocolo de aplicación que permite establecer una conexión persistente, bidireccional y full-duplex entre cliente y servidor sobre TCP.**

Desarmando la definición:

- **Persistente**  
    La conexión no se abre y cierra por cada mensaje.
    
- **Bidireccional**  
    Cliente y servidor pueden iniciar mensajes.
    
- **Full-duplex**  
    Ambos pueden enviar y recibir simultáneamente.
    
- **Sobre TCP**  
    No hay semántica request/response forzada.
    

WebSocket **no es HTTP**, aunque:

- usa HTTP solo para el _handshake_ inicial
    
- luego cambia a su propio protocolo
    

---

### A2.3 Qué problema real resuelve WebSocket

WebSocket resuelve problemas donde:

- el estado cambia frecuentemente
    
- el servidor debe notificar al cliente
    
- la latencia es crítica
    
- hay sesiones vivas
    
- el cliente no debe “preguntar” constantemente
    

Ejemplos reales:

- chats
    
- dashboards en tiempo real
    
- trading
    
- juegos online
    
- colaboración en vivo
    
- monitoreo
    

---

### A2.4 Modelo mental incorrecto (muy común)

> “WebSocket es REST pero sin cerrar la conexión.”

Este modelo es **peligroso**.

Lleva a:

- reutilizar lógica REST sin adaptarla
    
- no pensar en estado de conexión
    
- no manejar reconexión
    
- no manejar backpressure
    
- no pensar en escalado
    

---

### A2.5 Modelo mental correcto (ADVANCED)

> “WebSocket es un **canal de comunicación**, no un endpoint.”

Un canal:

- vive en el tiempo
    
- tiene estado
    
- puede romperse
    
- requiere protocolos internos
    
- necesita control de flujo
    

El desarrollador advanced **diseña un protocolo sobre WebSocket**, no solo “envía JSON”.

---

### A2.6 Elementos internos de un sistema WebSocket (desglosado)

#### A2.6.1 Handshake inicial

- Se inicia con HTTP
    
- Se valida:
    
    - autenticación
        
    - origen
        
    - permisos
        

Después del handshake:

- ya no hay headers HTTP
    
- ya no hay códigos HTTP
    

---

#### A2.6.2 Sesión viva

Una conexión WebSocket implica:

- recursos asignados
    
- memoria
    
- contexto
    
- posible estado asociado al usuario
    

Cada conexión **cuesta**.

---

#### A2.6.3 Mensajes

Un mensaje WebSocket:

- no tiene semántica HTTP
    
- no tiene verbos
    
- no tiene códigos de estado
    

La semántica la define **tu protocolo de aplicación**.

Ejemplo conceptual de mensaje:

```json
{
  "type": "PRICE_UPDATE",
  "payload": {
    "symbol": "BTC",
    "price": 62000
  }
}
```

---

### A2.7 Autenticación en WebSocket (punto crítico)

#### A2.7.1 Error típico

Autenticarse solo al inicio y:

- nunca revalidar
    
- nunca expirar
    
- nunca renovar credenciales
    

---

#### A2.7.2 Enfoque correcto

Opciones comunes:

- token JWT en handshake
    
- validación periódica
    
- cierre de conexión al expirar
    
- re-auth controlado
    

El advanced **diseña qué pasa cuando el token expira con la conexión viva**.

---

### A2.8 Heartbeats y detección de desconexión

WebSocket **no garantiza** que sabrás cuándo el otro lado murió.

Por eso se implementan:

- ping/pong
    
- heartbeats
    
- timeouts
    

Sin esto:

- conexiones zombis
    
- fugas de recursos
    
- estado inconsistente
    

---

### A2.9 Escalado horizontal (el gran problema)

WebSocket **rompe el escalado trivial**.

Problemas reales:

- conexiones persistentes
    
- sesiones distribuidas
    
- mensajes que deben llegar al cliente correcto
    

Soluciones típicas:

- sticky sessions
    
- brokers intermedios (Redis, Kafka)
    
- fan-out de eventos
    
- separación de gateway y lógica
    

---

### A2.10 Ejemplo correcto (diseño conceptual)

Sistema de notificaciones en tiempo real:

- API REST para autenticación y configuración
    
- Gateway WebSocket
    
- Broker de eventos
    
- Servicio productor de eventos
    

Flujo:

1. Cliente se autentica vía REST
    
2. Abre WebSocket con token
    
3. Gateway valida y registra conexión
    
4. Eventos llegan al broker
    
5. Gateway empuja eventos al cliente
    

---

### A2.11 Ejemplo incorrecto

- WebSocket directo a la lógica de negocio
    
- Sin broker
    
- Sin control de reconexión
    
- Sin deduplicación
    
- Sin límites
    

Resultado:

- caída bajo carga
    
- sesiones perdidas
    
- comportamiento impredecible
    

---

### A2.12 Errores típicos del principiante

- Tratar WebSocket como REST
    
- No manejar reconexión
    
- No pensar en escalado
    
- No pensar en seguridad
    
- No cerrar conexiones correctamente
    
- No medir consumo por conexión
    

---

### A2.13 Señales de comprensión real

Sabes que entiendes WebSocket cuando puedes:

- explicar por qué REST no sirve en ese caso
    
- diseñar tu propio protocolo de mensajes
    
- explicar cómo escalas miles de conexiones
    
- describir qué pasa al perder conexión
    
- justificar cómo manejas autenticación viva
    

---

### A2.14 Ejercicio práctico (obligatorio)

Diseña un sistema WebSocket para:

- 50 000 clientes concurrentes
    
- mensajes cada 2 segundos
    
- autenticación con expiración
    
- despliegue en múltiples nodos
    

Define:

- arquitectura
    
- autenticación
    
- reconexión
    
- escalado
    
- manejo de fallos
    

---

## A2.15 Transición

Ya entendimos:

- **qué es WebSocket**
    
- **qué problema resuelve**
    
- **qué complejidades introduce**
    

El siguiente paso natural es:

> **Webhooks**,  
> cuando el sistema **NO mantiene conexión**, pero necesita reaccionar a eventos externos.

---

## A3. Webhooks — Integración asincrónica basada en eventos

---

### A3.1 Contexto: por qué existen los Webhooks

Antes de los webhooks, la integración entre sistemas seguía este patrón:

- Sistema A necesita saber si algo cambió en Sistema B
    
- Sistema A pregunta cada cierto tiempo (polling)
    
- La mayoría de las veces no hay cambios
    
- Se desperdician recursos
    
- La latencia depende del intervalo de consulta
    

Este enfoque funcionaba cuando:

- los cambios eran poco frecuentes
    
- la latencia no era crítica
    
- el volumen era bajo
    

En sistemas **ADVANCED**, esto deja de ser viable.

Los webhooks aparecen para invertir el control:

> **El sistema que conoce el evento avisa cuando ocurre.**

---

### A3.2 Definición extensa y completamente desarmada

Un **Webhook** es:

> **Un mecanismo de notificación asincrónica donde un sistema emisor envía una solicitud HTTP a un endpoint del sistema receptor cuando ocurre un evento específico.**

Desarmando la definición:

- **Notificación**  
    No es una consulta; es un aviso.
    
- **Asincrónica**  
    El emisor no espera que el receptor “haga algo” más allá de confirmar recepción.
    
- **Evento**  
    Representa un hecho ocurrido, no una intención.
    
- **HTTP**  
    Se usa como medio de transporte, no como semántica REST completa.
    
- **Endpoint receptor**  
    El receptor debe estar preparado para recibir eventos en cualquier momento.
    

Un webhook **no es una API REST normal**, aunque use HTTP.

---

### A3.3 Qué problema real resuelve un Webhook

Webhooks son ideales cuando:

- el receptor no controla cuándo ocurre el evento
    
- el evento debe procesarse lo antes posible
    
- no se quiere mantener una conexión persistente
    
- los eventos son esporádicos pero importantes
    
- el emisor necesita desacoplarse del receptor
    

Ejemplos reales:

- pagos (confirmaciones, fallos)
    
- sistemas de envío
    
- plataformas de terceros
    
- integraciones SaaS
    
- CI/CD
    
- automatizaciones
    

---

### A3.4 Modelo mental incorrecto (muy común)

> “Un webhook es un POST como cualquier otro.”

Este modelo mental lleva a errores graves:

- no validar el origen
    
- no manejar duplicados
    
- no manejar reintentos
    
- no considerar orden
    
- no considerar idempotencia
    

---

### A3.5 Modelo mental correcto (ADVANCED)

> “Un webhook es un **evento externo no confiable** que puede:
> 
> - llegar tarde
>     
> - llegar varias veces
>     
> - llegar fuera de orden
>     
> - no llegar nunca”
>     

El sistema receptor debe ser **defensivo por diseño**.

---

### A3.6 Componentes internos de una integración por Webhook

#### A3.6.1 Evento

Un evento debe tener:

- tipo (`event_type`)
    
- identificador único (`event_id`)
    
- timestamp
    
- payload
    
- metadata (origen, versión, firma)
    

Sin identificador único, **no hay idempotencia**.

---

#### A3.6.2 Endpoint receptor

El endpoint:

- no debe asumir orden
    
- no debe asumir unicidad
    
- no debe asumir confiabilidad del emisor
    

Su responsabilidad primaria:

> **recibir, validar y confirmar recepción rápidamente**

---

#### A3.6.3 Confirmación (ACK)

La respuesta HTTP del receptor:

- solo confirma recepción
    
- no confirma procesamiento completo
    

Responder 2xx significa:

> “Recibí el evento y me hago cargo.”

---

### A3.7 Seguridad en Webhooks (crítica)

#### A3.7.1 Problema de seguridad

Cualquiera puede enviar un POST a tu endpoint.  
El receptor **no puede confiar** en el payload.

---

#### A3.7.2 Enfoques comunes de seguridad

- Firma HMAC del payload
    
- Secret compartido
    
- Certificados (mTLS)
    
- IP allowlist (débil por sí sola)
    

El receptor debe:

- verificar la firma
    
- rechazar eventos inválidos
    
- evitar replay attacks
    

---

### A3.8 Idempotencia (obligatoria en Webhooks)

#### A3.8.1 Por qué es necesaria

El emisor puede:

- reintentar si no recibe 2xx
    
- enviar el mismo evento más de una vez
    
- enviar eventos duplicados por error
    

Sin idempotencia:

- estados duplicados
    
- cobros duplicados
    
- inconsistencias graves
    

---

#### A3.8.2 Enfoque correcto

- Usar `event_id` como clave única
    
- Persistir eventos procesados
    
- Ignorar duplicados
    
- Procesar cada evento **una sola vez**
    

---

### A3.9 Reintentos y tolerancia a fallos

El emisor normalmente:

- reintenta con backoff
    
- deja de reintentar después de X intentos
    

El receptor debe:

- ser rápido
    
- no bloquear
    
- no hacer trabajo pesado sincrónico
    

---

### A3.10 Orden de eventos (tema complejo)

No todos los webhooks llegan en orden.

Estrategias:

- procesar sin asumir orden
    
- reordenar por timestamp (si aplica)
    
- diseñar lógica tolerante al desorden
    

Asumir orden **sin garantías explícitas** es un error grave.

---

### A3.11 Ejemplo correcto (flujo completo)

Sistema de pagos externo envía `payment.completed`:

1. Recibir POST
    
2. Verificar firma
    
3. Validar estructura
    
4. Verificar `event_id` (idempotencia)
    
5. Persistir evento recibido
    
6. Encolar procesamiento
    
7. Responder 2xx inmediatamente
    
8. Procesar en segundo plano
    

---

### A3.12 Ejemplo incorrecto

- Procesar todo en el request
    
- Llamar otros servicios sincrónicamente
    
- No verificar firma
    
- No deduplicar
    

Resultado:

- timeouts
    
- reintentos
    
- efectos duplicados
    

---

### A3.13 Errores típicos del principiante

- Pensar que el webhook llega una sola vez
    
- No validar origen
    
- No manejar idempotencia
    
- No persistir eventos
    
- No instrumentar logs y trazas
    
- No diferenciar recepción vs procesamiento
    

---

### A3.14 Señales de comprensión real

Sabes que entiendes Webhooks cuando puedes:

- explicar por qué respondes rápido
    
- explicar cómo deduplicas
    
- explicar cómo manejas reintentos
    
- explicar qué pasa si el evento llega tarde
    
- explicar cómo auditas eventos
    

---

### A3.15 Ejercicio práctico (obligatorio)

Diseña un receptor de webhooks para:

- 5 tipos de eventos
    
- hasta 15 reintentos por evento
    
- posibilidad de eventos fuera de orden
    
- volumen variable
    

Define:

- estructura del evento
    
- mecanismo de seguridad
    
- estrategia de idempotencia
    
- procesamiento asincrónico
    
- auditoría
    

---

## A3.16 Transición

Ya cubrimos:

- WebSocket (conexión persistente)
    
- Webhooks (eventos sin conexión)
    

El siguiente paso es:

> **gRPC**,  
> cuando la comunicación es **servicio a servicio**, de **alto rendimiento** y **contrato fuerte**.

---

## A4. gRPC — Comunicación RPC tipada y de alto rendimiento

---

## A4.1 Contexto: por qué aparece gRPC en sistemas avanzados

### Contexto histórico y técnico

En sistemas **ADVANCED**, especialmente con **microservicios**, empiezan a aparecer problemas serios con REST:

- demasiadas llamadas entre servicios
    
- payloads grandes en JSON
    
- parsing costoso
    
- contratos poco estrictos
    
- errores de compatibilidad silenciosos
    
- latencia acumulada entre hops
    
- dificultad para streaming real
    

En este escenario, REST **funciona**, pero **no es eficiente**.

gRPC aparece para resolver **comunicación servicio-a-servicio** donde:

- el control del contrato es crítico
    
- el rendimiento importa
    
- la latencia debe ser baja
    
- el volumen de llamadas es alto
    
- el sistema es interno (no navegador)
    

---

### Qué pasaba antes de gRPC

Antes de gRPC, se intentaba:

- REST interno “optimizado”
    
- JSON reducido
    
- HTTP keep-alive
    
- compresión
    
- convenciones estrictas manuales
    

Esto:

- requería mucha disciplina
    
- seguía siendo costoso
    
- no evitaba errores humanos
    

---

## A4.2 Definición extensa y completamente desarmada de gRPC

### Definición general

**gRPC** es:

> **Un framework de comunicación RPC (Remote Procedure Call) que utiliza HTTP/2 como transporte y Protocol Buffers (Protobuf) como lenguaje de definición de contratos, diseñado para comunicación eficiente y tipada entre servicios.**

Ahora lo desarmamos **pieza por pieza**.

---

### A4.2.1 RPC (Remote Procedure Call)

RPC significa:

> “Llamar a una función que se ejecuta en otro proceso o máquina como si fuera local.”

En gRPC:

- el cliente llama a un método
    
- el servidor lo ejecuta
    
- se intercambian mensajes binarios
    
- el transporte es transparente para el desarrollador
    

Esto **no es REST**:

- no hay recursos
    
- no hay verbos HTTP
    
- hay **métodos** y **mensajes**
    

---

### A4.2.2 HTTP/2 como transporte

gRPC usa HTTP/2 porque ofrece:

- multiplexación (muchas llamadas en una conexión)
    
- compresión de headers
    
- streams bidireccionales
    
- menor latencia
    
- mejor uso de la red
    

Esto resuelve:

- overhead de múltiples conexiones
    
- head-of-line blocking de HTTP/1.1
    

---

### A4.2.3 Protocol Buffers (Protobuf)

Protobuf es un **IDL (Interface Definition Language)**.

Sirve para:

- definir mensajes
    
- definir servicios
    
- definir métodos
    
- generar código automáticamente
    

Características clave:

- binario (más pequeño que JSON)
    
- tipado fuerte
    
- versionable
    
- rápido de serializar/deserializar
    

---

### A4.2.4 Contrato como código (punto crítico)

En gRPC:

- el contrato **no es documentación**
    
- el contrato **es código**
    
- se versiona
    
- se compila
    
- se valida
    

Esto cambia completamente el modelo mental.

---

## A4.3 Modelo mental incorrecto (muy común)

> “gRPC es REST pero más rápido.”

Este modelo mental produce errores graves:

- diseñar servicios RPC como endpoints REST
    
- no pensar en versionado
    
- romper compatibilidad del contrato
    
- ignorar streaming
    
- no definir límites claros
    

---

## A4.4 Modelo mental correcto (ADVANCED)

> “gRPC es una **API de funciones remotas**, con contratos estrictos, optimizada para comunicación interna de alto rendimiento.”

Un advanced entiende que con gRPC:

- el contrato es **sagrado**
    
- romper compatibilidad es costoso
    
- el diseño del proto importa tanto como el código
    
- la evolución debe ser planificada
    

---

## A4.5 Componentes internos de gRPC (desglosados)

### A4.5.1 Archivo `.proto`

Ejemplo conceptual:

```proto
service InventoryService {
  rpc CheckAvailability (ProductRequest) returns (AvailabilityResponse);
}

message ProductRequest {
  string product_id = 1;
}

message AvailabilityResponse {
  bool available = 1;
  int32 quantity = 2;
}
```

Aquí se define:

- qué se puede llamar
    
- qué datos entran
    
- qué datos salen
    

No hay ambigüedad.

---

### A4.5.2 Stubs (clientes generados)

A partir del proto:

- se genera cliente
    
- se genera servidor base
    
- se evitan errores manuales
    

Esto:

- reduce duplicación
    
- reduce errores humanos
    
- acelera desarrollo
    

---

### A4.5.3 Mensajes binarios

Comparado con JSON:

- más pequeños
    
- más rápidos
    
- menos flexibles
    
- más estrictos
    

Trade-off consciente.

---

## A4.6 Ejemplo correcto (uso apropiado)

Caso:

- microservicios internos
    
- alto volumen de llamadas
    
- bajo acoplamiento visual (no humano)
    
- control del ecosistema
    

Decisión correcta:

- gRPC interno
    
- REST hacia clientes externos
    
- gateway de traducción si es necesario
    

---

## A4.7 Ejemplo incorrecto

- Exponer gRPC directamente a navegadores
    
- No documentar el proto
    
- Cambiar campos sin reglas de compatibilidad
    
- Usar gRPC sin necesidad real
    

---

## A4.8 Errores típicos del principiante

- No entender reglas de versionado de Protobuf
    
- Quitar campos existentes
    
- Cambiar tipos
    
- No manejar errores correctamente
    
- No definir deadlines
    
- Tratar gRPC como REST
    

---

## A4.9 Señales de comprensión real

Sabes que entiendes gRPC cuando puedes:

- explicar cuándo usarlo y cuándo no
    
- diseñar un proto compatible en el tiempo
    
- explicar unary vs streaming
    
- explicar por qué no se expone directamente al frontend
    
- justificar el trade-off binario vs JSON
    

---

## A4.10 Ejercicio práctico (obligatorio)

Diseña un servicio gRPC interno para:

- 10 microservicios consumidores
    
- 3 versiones coexistiendo
    
- llamadas de alta frecuencia
    
- necesidad futura de streaming
    

Define:

- estructura del proto
    
- estrategia de versionado
    
- límites de compatibilidad
    
- manejo de errores
    

---


## A4.3 Tipos de comunicación en gRPC: Unary y Streaming (desarmado completo)

---

### A4.3.1 Contexto: por qué gRPC no es solo “request → response”

Uno de los errores más comunes al empezar con gRPC es usarlo **como si fuera REST**, es decir:

- una llamada
    
- una respuesta
    
- fin
    

Eso **desaprovecha** una de las capacidades más importantes de gRPC:

> **El soporte nativo de streaming sobre HTTP/2.**

gRPC fue diseñado para escenarios donde:

- hay flujo continuo de datos
    
- la comunicación es prolongada
    
- la latencia importa
    
- el volumen es alto
    
- el control de flujo es crítico
    

---

### A4.3.2 Definición extensa: tipos de llamadas gRPC

gRPC define **cuatro tipos de comunicación**, cada una con implicaciones muy distintas.

---

#### A4.3.2.1 Unary RPC (uno a uno)

**Definición**

- Un request
    
- Un response
    
- Modelo más parecido a REST
    

**Cuándo usarlo**

- Operaciones simples
    
- Consultas puntuales
    
- Comandos con respuesta inmediata
    

**Modelo mental correcto**

> “Unary es la opción más simple, no la más poderosa.”

---

#### A4.3.2.2 Server Streaming RPC (uno a muchos)

**Definición**

- El cliente envía una solicitud
    
- El servidor envía **un stream de respuestas**
    

Ejemplo conceptual:

- pedir historial
    
- recibir eventos progresivamente
    
- no esperar a que termine todo
    

**Qué problema resuelve**

- evita respuestas gigantes
    
- reduce latencia inicial
    
- permite procesar en tiempo real
    

---

#### A4.3.2.3 Client Streaming RPC (muchos a uno)

**Definición**

- El cliente envía múltiples mensajes
    
- El servidor responde una sola vez al final
    

Ejemplos reales:

- carga de grandes volúmenes
    
- envío de logs
    
- batch controlado
    

**Ventaja**

- control de flujo
    
- menos overhead que múltiples requests
    

---

#### A4.3.2.4 Bidirectional Streaming RPC (muchos a muchos)

**Definición**

- Cliente y servidor envían streams
    
- Comunicación simultánea
    
- Totalmente asincrónica
    

Ejemplos:

- chat
    
- sincronización
    
- pipelines de procesamiento
    
- coordinación en tiempo real
    

---

### A4.3.3 Modelo mental incorrecto (muy común)

> “Streaming es solo enviar muchos mensajes.”

Este modelo ignora:

- control de flujo
    
- backpressure
    
- orden
    
- cancelación
    
- finalización correcta
    

---

### A4.3.4 Modelo mental correcto (ADVANCED)

> “Streaming es **gestionar un canal de datos vivo**, no solo enviar mensajes.”

Un advanced piensa en:

- cuándo empieza
    
- cuándo termina
    
- qué pasa si uno falla
    
- qué pasa si el otro va más lento
    
- cómo se cancela
    

---

### A4.3.5 Backpressure en gRPC

gRPC (sobre HTTP/2) **soporta backpressure**, pero:

- no es automática por magia
    
- debe respetarse en el código
    
- requiere diseño consciente
    

Si el consumidor no puede procesar más:

- debe frenar al productor
    
- no acumular indefinidamente
    

Ignorar backpressure:

- provoca memory leaks
    
- provoca caídas bajo carga
    

---

### A4.3.6 Ejemplo correcto (conceptual)

Caso: streaming de métricas

- cliente se suscribe
    
- servidor envía métricas
    
- cliente procesa
    
- si el cliente se atrasa:
    
    - reduce consumo
        
    - servidor frena emisión
        

Esto mantiene estabilidad.

---

### A4.3.7 Ejemplo incorrecto

- servidor emite sin límite
    
- cliente no puede procesar
    
- memoria crece
    
- proceso cae
    

---

### A4.3.8 Errores típicos del principiante

- Usar streaming sin necesidad
    
- No cerrar streams
    
- No manejar cancelación
    
- Ignorar backpressure
    
- Mezclar lógica pesada en el stream
    
- No manejar errores intermedios
    

---

### A4.3.9 Señales de comprensión real

Sabes que entiendes streaming gRPC cuando puedes:

- explicar cuándo usar unary vs streaming
    
- explicar cómo manejar cancelación
    
- explicar backpressure
    
- explicar cómo cerrar correctamente un stream
    

---

### A4.3.10 Ejercicio práctico

Diseña un servicio gRPC con:

- streaming bidireccional
    
- volumen variable
    
- posibilidad de cancelación
    
- múltiples clientes concurrentes
    

Define:

- cuándo inicia el stream
    
- cuándo termina
    
- cómo manejas backpressure
    
- qué pasa si uno de los lados falla
    

---

## A4.4 Deadlines, timeouts y control de latencia en gRPC

---

### A4.4.1 Contexto: el problema real de la latencia

En sistemas distribuidos:

- las llamadas pueden tardar
    
- la red falla
    
- los servicios se saturan
    
- los recursos son finitos
    

Sin control de tiempo:

- los requests se acumulan
    
- los hilos se bloquean
    
- el sistema colapsa en cascada
    

---

### A4.4.2 Definición extensa: qué es un deadline

Un **deadline** es:

> **El tiempo máximo que un cliente está dispuesto a esperar por una respuesta.**

No es solo un timeout técnico.

Un deadline:

- expresa una expectativa de negocio
    
- protege recursos
    
- limita daño en cascada
    

---

### A4.4.3 Modelo mental incorrecto

> “Si no responde, espero un poco más.”

Esto mata sistemas.

---

### A4.4.4 Modelo mental correcto (ADVANCED)

> “Toda llamada remota **debe tener un límite temporal explícito**.”

Si no hay deadline:

- el sistema no tiene control
    
- el fallo se propaga
    

---

### A4.4.5 Deadlines como contrato

En gRPC:

- el cliente envía el deadline
    
- el servidor lo recibe
    
- el servidor **debe respetarlo**
    

Esto permite:

- cancelación temprana
    
- liberar recursos
    
- evitar trabajo inútil
    

---

### A4.4.6 Timeouts vs Deadlines

- **Timeout**: límite local
    
- **Deadline**: límite distribuido (viaja con la llamada)
    

En microservicios:

- el deadline debe propagarse
    
- cada servicio consume parte del tiempo disponible
    

---

### A4.4.7 Ejemplo correcto

Cliente:

- define deadline de 300ms
    

Servicio A:

- consume 100ms
    
- llama a Servicio B con deadline restante (200ms)
    

Servicio B:

- responde o cancela
    

Esto evita cascadas.

---

### A4.4.8 Ejemplo incorrecto

- no definir deadlines
    
- cada servicio espera indefinidamente
    
- saturación progresiva
    
- caída total
    

---

### A4.4.9 Errores típicos del principiante

- No definir deadlines
    
- Definir deadlines absurdamente altos
    
- No propagar deadlines
    
- Ignorar cancelaciones
    
- Reintentar sin límite
    

---

### A4.4.10 Señales de comprensión real

Sabes que entiendes este tema cuando:

- puedes justificar un deadline
    
- sabes cómo propagarlo
    
- sabes cuándo cancelar
    
- sabes cuándo no reintentar
    

---

### A4.4.11 Ejercicio práctico

Diseña un flujo de microservicios con:

- 3 llamadas encadenadas
    
- deadline global de 500ms
    

Define:

- cuánto tiempo consume cada servicio
    
- cómo se propaga el deadline
    
- qué pasa si uno falla
    
- cómo evitas cascada
    

---

## A4.3 Tipos de comunicación en gRPC: Unary y Streaming (desarmado completo)

---

### A4.3.1 Contexto: por qué gRPC no es solo “request → response”

Uno de los errores más comunes al empezar con gRPC es usarlo **como si fuera REST**, es decir:

- una llamada
    
- una respuesta
    
- fin
    

Eso **desaprovecha** una de las capacidades más importantes de gRPC:

> **El soporte nativo de streaming sobre HTTP/2.**

gRPC fue diseñado para escenarios donde:

- hay flujo continuo de datos
    
- la comunicación es prolongada
    
- la latencia importa
    
- el volumen es alto
    
- el control de flujo es crítico
    

---

### A4.3.2 Definición extensa: tipos de llamadas gRPC

gRPC define **cuatro tipos de comunicación**, cada una con implicaciones muy distintas.

---

#### A4.3.2.1 Unary RPC (uno a uno)

**Definición**

- Un request
    
- Un response
    
- Modelo más parecido a REST
    

**Cuándo usarlo**

- Operaciones simples
    
- Consultas puntuales
    
- Comandos con respuesta inmediata
    

**Modelo mental correcto**

> “Unary es la opción más simple, no la más poderosa.”

---

#### A4.3.2.2 Server Streaming RPC (uno a muchos)

**Definición**

- El cliente envía una solicitud
    
- El servidor envía **un stream de respuestas**
    

Ejemplo conceptual:

- pedir historial
    
- recibir eventos progresivamente
    
- no esperar a que termine todo
    

**Qué problema resuelve**

- evita respuestas gigantes
    
- reduce latencia inicial
    
- permite procesar en tiempo real
    

---

#### A4.3.2.3 Client Streaming RPC (muchos a uno)

**Definición**

- El cliente envía múltiples mensajes
    
- El servidor responde una sola vez al final
    

Ejemplos reales:

- carga de grandes volúmenes
    
- envío de logs
    
- batch controlado
    

**Ventaja**

- control de flujo
    
- menos overhead que múltiples requests
    

---

#### A4.3.2.4 Bidirectional Streaming RPC (muchos a muchos)

**Definición**

- Cliente y servidor envían streams
    
- Comunicación simultánea
    
- Totalmente asincrónica
    

Ejemplos:

- chat
    
- sincronización
    
- pipelines de procesamiento
    
- coordinación en tiempo real
    

---

### A4.3.3 Modelo mental incorrecto (muy común)

> “Streaming es solo enviar muchos mensajes.”

Este modelo ignora:

- control de flujo
    
- backpressure
    
- orden
    
- cancelación
    
- finalización correcta
    

---

### A4.3.4 Modelo mental correcto (ADVANCED)

> “Streaming es **gestionar un canal de datos vivo**, no solo enviar mensajes.”

Un advanced piensa en:

- cuándo empieza
    
- cuándo termina
    
- qué pasa si uno falla
    
- qué pasa si el otro va más lento
    
- cómo se cancela
    

---

### A4.3.5 Backpressure en gRPC

gRPC (sobre HTTP/2) **soporta backpressure**, pero:

- no es automática por magia
    
- debe respetarse en el código
    
- requiere diseño consciente
    

Si el consumidor no puede procesar más:

- debe frenar al productor
    
- no acumular indefinidamente
    

Ignorar backpressure:

- provoca memory leaks
    
- provoca caídas bajo carga
    

---

### A4.3.6 Ejemplo correcto (conceptual)

Caso: streaming de métricas

- cliente se suscribe
    
- servidor envía métricas
    
- cliente procesa
    
- si el cliente se atrasa:
    
    - reduce consumo
        
    - servidor frena emisión
        

Esto mantiene estabilidad.

---

### A4.3.7 Ejemplo incorrecto

- servidor emite sin límite
    
- cliente no puede procesar
    
- memoria crece
    
- proceso cae
    

---

### A4.3.8 Errores típicos del principiante

- Usar streaming sin necesidad
    
- No cerrar streams
    
- No manejar cancelación
    
- Ignorar backpressure
    
- Mezclar lógica pesada en el stream
    
- No manejar errores intermedios
    

---

### A4.3.9 Señales de comprensión real

Sabes que entiendes streaming gRPC cuando puedes:

- explicar cuándo usar unary vs streaming
    
- explicar cómo manejar cancelación
    
- explicar backpressure
    
- explicar cómo cerrar correctamente un stream
    

---

### A4.3.10 Ejercicio práctico

Diseña un servicio gRPC con:

- streaming bidireccional
    
- volumen variable
    
- posibilidad de cancelación
    
- múltiples clientes concurrentes
    

Define:

- cuándo inicia el stream
    
- cuándo termina
    
- cómo manejas backpressure
    
- qué pasa si uno de los lados falla
    

---

## A4.4 Deadlines, timeouts y control de latencia en gRPC

---

### A4.4.1 Contexto: el problema real de la latencia

En sistemas distribuidos:

- las llamadas pueden tardar
    
- la red falla
    
- los servicios se saturan
    
- los recursos son finitos
    

Sin control de tiempo:

- los requests se acumulan
    
- los hilos se bloquean
    
- el sistema colapsa en cascada
    

---

### A4.4.2 Definición extensa: qué es un deadline

Un **deadline** es:

> **El tiempo máximo que un cliente está dispuesto a esperar por una respuesta.**

No es solo un timeout técnico.

Un deadline:

- expresa una expectativa de negocio
    
- protege recursos
    
- limita daño en cascada
    

---

### A4.4.3 Modelo mental incorrecto

> “Si no responde, espero un poco más.”

Esto mata sistemas.

---

### A4.4.4 Modelo mental correcto (ADVANCED)

> “Toda llamada remota **debe tener un límite temporal explícito**.”

Si no hay deadline:

- el sistema no tiene control
    
- el fallo se propaga
    

---

### A4.4.5 Deadlines como contrato

En gRPC:

- el cliente envía el deadline
    
- el servidor lo recibe
    
- el servidor **debe respetarlo**
    

Esto permite:

- cancelación temprana
    
- liberar recursos
    
- evitar trabajo inútil
    

---

### A4.4.6 Timeouts vs Deadlines

- **Timeout**: límite local
    
- **Deadline**: límite distribuido (viaja con la llamada)
    

En microservicios:

- el deadline debe propagarse
    
- cada servicio consume parte del tiempo disponible
    

---

### A4.4.7 Ejemplo correcto

Cliente:

- define deadline de 300ms
    

Servicio A:

- consume 100ms
    
- llama a Servicio B con deadline restante (200ms)
    

Servicio B:

- responde o cancela
    

Esto evita cascadas.

---

### A4.4.8 Ejemplo incorrecto

- no definir deadlines
    
- cada servicio espera indefinidamente
    
- saturación progresiva
    
- caída total
    

---

### A4.4.9 Errores típicos del principiante

- No definir deadlines
    
- Definir deadlines absurdamente altos
    
- No propagar deadlines
    
- Ignorar cancelaciones
    
- Reintentar sin límite
    

---

### A4.4.10 Señales de comprensión real

Sabes que entiendes este tema cuando:

- puedes justificar un deadline
    
- sabes cómo propagarlo
    
- sabes cuándo cancelar
    
- sabes cuándo no reintentar
    

---

### A4.4.11 Ejercicio práctico

Diseña un flujo de microservicios con:

- 3 llamadas encadenadas
    
- deadline global de 500ms
    

Define:

- cuánto tiempo consume cada servicio
    
- cómo se propaga el deadline
    
- qué pasa si uno falla
    
- cómo evitas cascada
    

---

## A4.5 Interceptors, manejo de errores y versionado en gRPC (núcleo operativo real)

---

### A4.5.1 Contexto: por qué el “happy path” no existe en producción

En ejemplos simples de gRPC se ve:

- cliente llama
    
- servidor responde
    
- todo funciona
    

En sistemas **ADVANCED**, esto es la excepción.

En producción existen:

- errores parciales
    
- timeouts
    
- cancelaciones
    
- autenticación
    
- autorización
    
- métricas
    
- trazabilidad
    
- versionado vivo
    

Aquí aparecen los **interceptors** como pieza central.

---

### A4.5.2 Definición extensa: qué es un interceptor en gRPC

Un **interceptor** es:

> **Un componente que intercepta la ejecución de una llamada gRPC antes, durante o después del método real, para aplicar lógica transversal.**

Transversal significa:

- no pertenece al dominio
    
- no pertenece a un caso de uso
    
- afecta a todas o muchas llamadas
    

Ejemplos de responsabilidades transversales:

- autenticación
    
- autorización
    
- logging
    
- tracing
    
- métricas
    
- manejo de errores
    
- propagación de contexto
    
- validaciones técnicas
    

---

### A4.5.3 Modelo mental incorrecto

> “Interceptor = filtro automático donde meto lógica.”

Esto lleva a:

- lógica de negocio en interceptors
    
- acoplamiento oculto
    
- comportamiento difícil de rastrear
    

---

### A4.5.4 Modelo mental correcto (ADVANCED)

> “Interceptor = **infraestructura declarativa**, no lógica de negocio.”

Un advanced usa interceptors para:

- **preparar el contexto**
    
- **proteger el sistema**
    
- **observar el comportamiento**
    
- **enriquecer la llamada**
    

Nunca para decidir reglas de negocio.

---

### A4.5.5 Interceptors típicos y su función real

#### A4.5.5.1 Interceptor de autenticación

Responsabilidad:

- extraer credenciales (metadata)
    
- validar token/certificado
    
- poblar contexto de seguridad
    
- rechazar llamadas inválidas
    

Nunca debe:

- decidir permisos de negocio
    
- acceder a base de datos de dominio
    

---

#### A4.5.5.2 Interceptor de autorización

Responsabilidad:

- verificar permisos técnicos
    
- validar scopes/roles
    
- permitir o negar acceso
    

Debe ser:

- rápido
    
- determinista
    
- predecible
    

---

#### A4.5.5.3 Interceptor de observabilidad

Incluye:

- logging estructurado
    
- tracing distribuido
    
- métricas (latencia, errores, volumen)
    

Sin esto:

- gRPC se vuelve una “caja negra”
    

---

### A4.5.6 Manejo de errores en gRPC (muy distinto a REST)

#### A4.5.6.1 Problema común

Muchos desarrolladores intentan:

- devolver errores como payloads
    
- simular HTTP status codes
    

Esto rompe el modelo gRPC.

---

#### A4.5.6.2 Modelo correcto de errores en gRPC

En gRPC:

- los errores tienen **status codes propios**
    
- los errores son **parte del contrato**
    
- el cliente debe poder reaccionar
    

Ejemplos conceptuales:

- INVALID_ARGUMENT
    
- NOT_FOUND
    
- PERMISSION_DENIED
    
- DEADLINE_EXCEEDED
    
- UNAVAILABLE
    

Cada uno comunica:

- qué pasó
    
- si se puede reintentar
    
- si el cliente debe cambiar algo
    

---

### A4.5.7 Errores de negocio vs errores técnicos

Un advanced distingue:

- **Error de negocio**
    
    - regla violada
        
    - no se reintenta
        
    - se comunica claramente
        
- **Error técnico**
    
    - infraestructura
        
    - red
        
    - timeout
        
    - puede reintentarse
        

Mezclarlos es un antipatrón grave.

---

### A4.5.8 Versionado de Protobuf (tema crítico)

#### A4.5.8.1 Contexto

En gRPC:

- el contrato vive mucho tiempo
    
- múltiples versiones coexisten
    
- romper compatibilidad es costoso
    

---

#### A4.5.8.2 Reglas fundamentales de compatibilidad

Un advanced sabe que:

- **Nunca** se elimina un campo
    
- **Nunca** se reutiliza un número de campo
    
- Se pueden agregar campos opcionales
    
- Se pueden agregar nuevos mensajes
    
- Se puede evolucionar sin romper clientes antiguos
    

Ignorar esto:

- rompe clientes en runtime
    
- genera bugs silenciosos
    

---

### A4.5.9 Modelo mental correcto de versionado

> “El proto es un contrato histórico, no una clase editable libremente.”

Cada cambio:

- debe ser pensado a largo plazo
    
- debe considerar clientes antiguos
    
- debe documentarse
    

---

### A4.5.10 Errores típicos del principiante

- Cambiar tipos de campos
    
- Reutilizar field numbers
    
- Eliminar campos “que ya no se usan”
    
- No versionar servicios
    
- No probar compatibilidad hacia atrás
    

---

### A4.5.11 Señales de comprensión real

Sabes que entiendes este punto cuando:

- puedes explicar por qué un campo nunca se elimina
    
- sabes diseñar un proto evolutivo
    
- sabes mapear errores gRPC a decisiones de cliente
    
- sabes qué errores se reintentan y cuáles no
    

---

### A4.5.12 Ejercicio práctico

Diseña la evolución de un proto:

- versión v1 ya en producción
    
- 3 clientes activos
    
- necesitas agregar nueva información
    
- uno de los campos actuales queda obsoleto
    

Define:

- cómo evolucionas sin romper
    
- qué dejas deprecated
    
- cómo comunicas el cambio
    

---

## A4.6 Antipatrones gRPC en sistemas ADVANCED

---

### A4.6.1 Antipatrón: gRPC como REST binario

Síntomas:

- métodos llamados `getSomething`, `postSomething`
    
- diseño orientado a recursos
    
- ignorar streaming
    

Impacto:

- desaprovechar gRPC
    
- contratos pobres
    
- complejidad innecesaria
    

---

### A4.6.2 Antipatrón: Sin deadlines

Síntomas:

- llamadas colgadas
    
- hilos bloqueados
    
- cascadas de fallos
    

Impacto:

- caída progresiva del sistema
    

---

### A4.6.3 Antipatrón: Lógica de negocio en interceptors

Síntomas:

- decisiones escondidas
    
- comportamiento inesperado
    
- tests complejos
    

Impacto:

- arquitectura opaca
    
- bugs difíciles
    

---

### A4.6.4 Antipatrón: Versionado descuidado

Síntomas:

- cambios “rápidos” al proto
    
- clientes rompiéndose
    
- rollback urgente
    

Impacto:

- pérdida de confianza
    
- deuda técnica grave
    

---

### A4.6.5 Antipatrón: gRPC para todo

Síntomas:

- usar gRPC donde REST era suficiente
    
- exponer gRPC a clientes web sin gateway
    
- tooling inadecuado
    

Impacto:

- complejidad innecesaria
    
- barrera de entrada al equipo
    

---

## A5. Mensajería avanzada — AMQP, MQTT, STOMP, XMPP, Pub/Sub

---

## A5.1 Contexto: por qué aparece la mensajería en sistemas ADVANCED

### A5.1.1 El problema estructural que REST/gRPC/WebSocket no resuelven del todo

Incluso usando:

- REST
    
- WebSocket
    
- gRPC
    

aparece un problema **inevitable** en sistemas complejos:

> **El acoplamiento temporal entre productor y consumidor.**

Qué significa esto:

- el productor envía algo
    
- el consumidor **debe** estar disponible ahora
    
- si no lo está:
    
    - falla
        
    - hay reintentos
        
    - hay cascadas
        
    - hay pérdida de estabilidad
        

En sistemas ADVANCED:

- los servicios caen
    
- se despliegan
    
- se escalan
    
- se reinician
    
- se congestionan
    

Y aun así:

- el sistema debe seguir funcionando
    

---

### A5.1.2 Qué pasaba antes de la mensajería

Antes de mensajería:

- llamadas sincrónicas
    
- retries agresivos
    
- timeouts
    
- lógica de compensación manual
    
- sistemas frágiles
    

Esto funcionaba:

- a pequeña escala
    
- con pocos servicios
    
- con baja variabilidad
    

A gran escala:

- no sobrevive
    

---

### A5.1.3 Definición extensa: qué es mensajería

**Mensajería** es:

> **Un modelo de comunicación asincrónica donde los productores envían mensajes a un intermediario (broker) y los consumidores los reciben de manera desacoplada en el tiempo y el espacio.**

Desarmando la definición:

- **Asincrónica**  
    El productor no espera respuesta inmediata.
    
- **Desacoplada en el tiempo**  
    El consumidor puede no estar disponible ahora.
    
- **Desacoplada en el espacio**  
    El productor no conoce al consumidor.
    
- **Intermediario (broker)**  
    Responsable de almacenar, enrutar y entregar mensajes.
    
- **Mensaje**  
    Unidad de información inmutable que representa un hecho o intención.
    

---

### A5.1.4 Qué problemas reales resuelve la mensajería

Mensajería resuelve:

- picos de carga
    
- desacoplamiento
    
- resiliencia
    
- buffering
    
- fan-out
    
- integración entre dominios
    
- consistencia eventual
    

Es **fundamental** en arquitecturas avanzadas.

---

### A5.1.5 Modelo mental incorrecto (muy común)

> “Mensajería es solo REST pero más lento.”

Este modelo mental lleva a:

- usarla mal
    
- duplicar lógica
    
- frustración
    
- sistemas inconsistentes
    

---

### A5.1.6 Modelo mental correcto (ADVANCED)

> “Mensajería es un **mecanismo de coordinación temporal**, no de respuesta inmediata.”

Un advanced entiende que:

- no hay respuesta directa
    
- no hay garantía de orden absoluto (salvo configuración)
    
- no hay garantía de tiempo inmediato
    
- hay **trade-offs claros**
    

---

## A5.2 Modelos fundamentales de mensajería: Queue vs Pub/Sub

---

### A5.2.1 Contexto: no toda mensajería es igual

Uno de los errores más graves es:

- usar cualquier broker
    
- sin entender el modelo
    
- asumir comportamientos incorrectos
    

Antes de elegir tecnología:

> **Hay que entender el modelo de comunicación.**

---

### A5.2.2 Modelo Queue (cola)

#### Definición

En el modelo **Queue**:

- un productor envía mensajes a una cola
    
- uno (y solo uno) de los consumidores recibe cada mensaje
    
- el mensaje se elimina una vez procesado (ack)
    

Es un modelo **1 → 1 lógico**, aunque haya muchos consumidores.

---

#### Qué problema resuelve

- distribución de trabajo
    
- balanceo de carga
    
- procesamiento paralelo
    
- desacoplamiento productor/consumidor
    

Ejemplos:

- procesamiento de órdenes
    
- envío de emails
    
- jobs en background
    
- pipelines de datos
    

---

#### Modelo mental correcto

> “Una cola distribuye trabajo, no información.”

---

#### Ejemplo correcto (conceptual)

- Servicio A produce trabajos
    
- Cola almacena
    
- Servicio B, C y D consumen
    
- Cada mensaje se procesa **una sola vez**
    

---

#### Ejemplo incorrecto

- Usar cola para notificar a múltiples servicios
    
- Esperar que todos reciban el mensaje
    

Eso **no ocurre** en Queue.

---

#### Errores típicos del principiante

- Asumir orden absoluto
    
- No manejar reintentos
    
- No manejar mensajes fallidos
    
- No diseñar idempotencia
    
- No definir dead-letter queue
    

---

### A5.2.3 Modelo Pub/Sub (publicación–suscripción)

#### Definición

En **Pub/Sub**:

- el productor publica un mensaje en un tópico
    
- múltiples consumidores pueden suscribirse
    
- **cada consumidor recibe su propia copia**
    

Es un modelo **1 → N**.

---

#### Qué problema resuelve

- propagación de eventos
    
- integración entre dominios
    
- reacciones independientes
    
- desacoplamiento fuerte
    

Ejemplos:

- eventos de negocio
    
- auditoría
    
- notificaciones
    
- sincronización entre sistemas
    

---

#### Modelo mental correcto

> “Pub/Sub distribuye información, no trabajo.”

---

#### Ejemplo correcto

- Servicio A publica `OrderCreated`
    
- Servicio B actualiza inventario
    
- Servicio C envía email
    
- Servicio D genera métricas
    

Todos reciben el evento.

---

#### Ejemplo incorrecto

- Usar Pub/Sub para repartir trabajo pesado
    
- Esperar balanceo automático
    

Eso genera:

- duplicación
    
- sobrecarga
    
- inconsistencias
    

---

### A5.2.4 Diferencias críticas Queue vs Pub/Sub (conceptuales)

|Aspecto|Queue|Pub/Sub|
|---|---|---|
|Consumidores|Uno por mensaje|Muchos|
|Objetivo|Trabajo|Información|
|Escalado|Paralelismo|Fan-out|
|Duplicación|No|Sí|
|Caso típico|Jobs|Eventos|

---

### A5.2.5 Errores de diseño comunes

- Usar Queue cuando necesitas fan-out
    
- Usar Pub/Sub cuando necesitas balanceo
    
- No entender garantías de entrega
    
- Mezclar modelos sin control
    

---

### A5.2.6 Señales de comprensión real

Sabes que entiendes este punto cuando:

- puedes justificar **por qué** eliges Queue o Pub/Sub
    
- puedes explicar qué pasa si un consumidor cae
    
- sabes qué se duplica y qué no
    
- sabes qué tipo de problema estás resolviendo
    

---

### A5.2.7 Ejercicio práctico (obligatorio)

Diseña dos flujos:

1. Procesamiento de imágenes (trabajo pesado)
    
2. Notificación de eventos de negocio
    

Para cada uno define:

- modelo (Queue o Pub/Sub)
    
- por qué
    
- qué pasa si un consumidor cae
    
- cómo escalarías
    

---

## A5.3 Garantías de entrega, QoS y reintentos (el corazón de la mensajería)

---

### A5.3.1 Contexto: el mito de “el mensaje llega”

En sistemas **ADVANCED**, una de las primeras ilusiones que se rompen es esta:

> “Si envié el mensaje, entonces llegó.”

En sistemas distribuidos:

- la red falla
    
- los brokers se reinician
    
- los consumidores se caen
    
- los mensajes se duplican
    
- los mensajes se pierden
    

Por eso, **la garantía de entrega no es implícita**, es una **decisión de diseño**.

---

### A5.3.2 Definición extensa: qué es una garantía de entrega

Una **garantía de entrega** define:

- cuántas veces puede llegar un mensaje
    
- qué pasa si falla el consumidor
    
- qué hace el broker con mensajes no confirmados
    
- qué nivel de confiabilidad ofrece el sistema
    

No existe “entrega perfecta” sin costo.

---

### A5.3.3 Tipos clásicos de garantías de entrega

#### A5.3.3.1 At-most-once (a lo sumo una vez)

**Definición**

- el mensaje se envía
    
- puede perderse
    
- nunca se duplica
    

**Ventajas**

- bajo costo
    
- baja latencia
    

**Desventajas**

- pérdida de mensajes
    

**Cuándo usarlo**

- métricas
    
- logs no críticos
    
- telemetría
    

---

#### A5.3.3.2 At-least-once (al menos una vez)

**Definición**

- el mensaje se reintenta hasta confirmación
    
- puede llegar más de una vez
    

**Ventajas**

- no se pierde información
    

**Desventajas**

- duplicados
    

**Requisito clave**

> **Consumidores idempotentes**

Este es el modelo **más común** en sistemas reales.

---

#### A5.3.3.3 Exactly-once (exactamente una vez)

**Definición**

- el mensaje se procesa una sola vez
    
- sin duplicados
    
- sin pérdidas
    

**Realidad**

> **Es extremadamente costoso y limitado.**

Generalmente:

- depende del broker
    
- depende del almacenamiento
    
- no es global
    
- no es trivial
    

---

### A5.3.4 Modelo mental incorrecto

> “Quiero exactly-once para todo.”

Esto suele llevar a:

- sistemas lentos
    
- complejidad extrema
    
- falsa sensación de seguridad
    

---

### A5.3.5 Modelo mental correcto (ADVANCED)

> “Elijo la garantía mínima que resuelve el problema sin romper el sistema.”

Un advanced:

- acepta duplicados
    
- diseña idempotencia
    
- evita complejidad innecesaria
    

---

### A5.3.6 Reintentos: necesarios pero peligrosos

#### A5.3.6.1 Por qué existen los reintentos

Reintentar:

- protege contra fallos temporales
    
- permite resiliencia
    

Pero reintentar mal:

- amplifica fallos
    
- satura sistemas
    
- provoca tormentas de mensajes
    

---

#### A5.3.6.2 Reintentos con backoff

Buenas prácticas:

- backoff exponencial
    
- jitter (aleatoriedad)
    
- límite de reintentos
    

Nunca:

- reintentos infinitos
    
- reintentos inmediatos sin control
    

---

### A5.3.7 Dead Letter Queue (DLQ)

#### Definición

Una **DLQ** es:

> una cola secundaria donde van los mensajes que no pudieron procesarse después de varios intentos.

Sirve para:

- inspección
    
- debugging
    
- reprocesamiento manual
    
- auditoría
    

---

### A5.3.8 Errores típicos del principiante

- No definir DLQ
    
- Reintentar infinitamente
    
- No diferenciar error transitorio vs permanente
    
- No instrumentar reintentos
    
- No alertar sobre DLQ creciendo
    

---

### A5.3.9 Señales de comprensión real

Sabes que entiendes este tema cuando:

- puedes justificar la garantía elegida
    
- sabes por qué no usas exactly-once
    
- diseñas consumidores idempotentes
    
- sabes qué hacer con mensajes fallidos
    

---

### A5.3.10 Ejercicio práctico

Diseña un flujo de mensajería para:

- pagos
    
- posibilidad de fallos
    
- impacto alto
    

Define:

- garantía de entrega
    
- estrategia de idempotencia
    
- política de reintentos
    
- manejo de DLQ
    

---

## A5.4 Backpressure, orden y consistencia en mensajería

---

### A5.4.1 Contexto: cuando el consumidor es más lento que el productor

En sistemas reales:

- el productor puede producir más rápido
    
- el consumidor puede ralentizarse
    
- los picos son inevitables
    

Sin control:

- colas crecen
    
- memoria se agota
    
- latencia se dispara
    
- sistema colapsa
    

Este problema se llama **backpressure**.

---

### A5.4.2 Definición extensa: qué es backpressure

Backpressure es:

> **Un mecanismo para controlar el ritmo de producción de mensajes cuando los consumidores no pueden procesar al mismo ritmo.**

No es opcional.  
Es **necesario para la estabilidad**.

---

### A5.4.3 Modelo mental incorrecto

> “Si se llena la cola, agrego más consumidores.”

Eso no siempre funciona:

- hay límites físicos
    
- hay dependencias
    
- hay cuellos de botella aguas abajo
    

---

### A5.4.4 Modelo mental correcto (ADVANCED)

> “El sistema debe poder **frenar** la producción de manera controlada.”

Esto puede implicar:

- rechazar mensajes
    
- degradar funcionalidades
    
- priorizar
    
- bufferizar con límites
    

---

### A5.4.5 Estrategias de backpressure

- límites de tamaño de cola
    
- control de tasa (rate limiting)
    
- pull-based consumption
    
- ventanas deslizantes
    
- priorización de mensajes
    

Cada estrategia tiene trade-offs.

---

### A5.4.6 Orden de mensajes (tema delicado)

No todos los sistemas garantizan orden.

Preguntas clave:

- ¿necesito orden absoluto?
    
- ¿orden por clave?
    
- ¿puedo tolerar desorden?
    

Forzar orden:

- reduce paralelismo
    
- reduce throughput
    

---

### A5.4.7 Consistencia eventual

Mensajería implica:

- retrasos
    
- asincronía
    
- estados intermedios
    

Esto no es un bug:

> **Es una propiedad del sistema.**

El diseño debe:

- tolerar estados transitorios
    
- evitar suposiciones de inmediatez
    
- comunicar consistencia eventual al negocio
    

---

### A5.4.8 Ejemplo correcto

Sistema de órdenes:

- evento `OrderPlaced`
    
- inventario se actualiza luego
    
- UI muestra “pendiente”
    

No se asume consistencia inmediata.

---

### A5.4.9 Ejemplo incorrecto

- asumir que el evento ya fue procesado
    
- leer estado inmediatamente
    
- mostrar información incorrecta
    

---

### A5.4.10 Errores típicos del principiante

- Ignorar backpressure
    
- Asumir orden absoluto
    
- No diseñar para consistencia eventual
    
- Bloquear productores
    
- No comunicar estados intermedios
    

---

### A5.4.11 Señales de comprensión real

Sabes que entiendes mensajería avanzada cuando:

- puedes explicar qué pasa bajo picos
    
- sabes cómo frenar producción
    
- aceptas consistencia eventual
    
- puedes justificar trade-offs
    

---

### A5.4.12 Ejercicio práctico

Diseña un sistema con:

- productores rápidos
    
- consumidores lentos
    
- necesidad de orden parcial
    

Define:

- estrategia de backpressure
    
- modelo de orden
    
- cómo comunicas estados intermedios
    

---

## A6. GraphQL — Contratos flexibles, poder real y riesgos sistémicos

---

### A6.1 Contexto: por qué aparece GraphQL

GraphQL aparece cuando los sistemas REST empiezan a mostrar **fricciones estructurales** en escenarios como:

- múltiples clientes (web, mobile, partners)
    
- pantallas con necesidades de datos muy distintas
    
- overfetching (traer datos que no se usan)
    
- underfetching (múltiples llamadas para completar una vista)
    
- evolución rápida del frontend
    
- latencias acumuladas por muchas requests
    

Antes de GraphQL, se intentaba resolver esto con:

- endpoints específicos por pantalla
    
- agregadores backend
    
- BFFs cada vez más complejos
    
- versionado agresivo de APIs
    

Estos enfoques funcionan, pero **aumentan el costo de mantenimiento**.

GraphQL surge para cambiar el eje:

> **El cliente declara qué datos necesita;  
> el servidor responde exactamente eso.**

---

### A6.2 Definición extensa y completamente desarmada

GraphQL es:

> **Un lenguaje de consulta y un runtime para APIs que permite a los clientes especificar de forma declarativa la estructura exacta de los datos que necesitan, sobre un esquema fuertemente tipado definido por el servidor.**

Desarmando la definición:

- **Lenguaje de consulta**  
    No es SQL, no es REST; es un DSL para datos.
    
- **Runtime**  
    Requiere un motor que ejecute las consultas.
    
- **Declarativo**  
    El cliente describe la forma del resultado.
    
- **Esquema tipado**  
    El contrato está definido por tipos y relaciones.
    
- **Servidor controla el esquema**  
    El cliente no puede pedir lo que no existe.
    

GraphQL **no es solo un endpoint**, es **un sistema de ejecución**.

---

### A6.3 Qué problema real resuelve GraphQL

GraphQL es útil cuando:

- muchos clientes consumen la misma API
    
- cada cliente necesita combinaciones distintas de datos
    
- el frontend evoluciona rápido
    
- se quiere evitar crear endpoints por vista
    
- se busca reducir el número de round-trips
    

Ejemplos reales:

- aplicaciones móviles
    
- dashboards complejos
    
- productos con múltiples equipos frontend
    
- integraciones con partners
    

---

### A6.4 Modelo mental incorrecto (muy común)

> “GraphQL elimina la necesidad de diseño backend.”

Este modelo mental es **peligrosísimo**.

Lleva a:

- esquemas caóticos
    
- consultas carísimas
    
- problemas de performance
    
- APIs imposibles de proteger
    
- debugging complejo
    

---

### A6.5 Modelo mental correcto (ADVANCED)

> “GraphQL **traslada poder al cliente**,  
> pero **aumenta la responsabilidad del servidor**.”

Un backend advanced entiende que con GraphQL:

- el servidor debe protegerse
    
- el esquema es diseño de dominio
    
- la ejecución debe ser controlada
    
- la performance debe ser anticipada
    

---

### A6.6 Componentes internos de GraphQL (desglosados)

#### A6.6.1 Esquema (Schema)

El esquema define:

- tipos
    
- relaciones
    
- queries
    
- mutations
    
- subscriptions
    

Ejemplo conceptual:

```graphql
type Query {
  order(id: ID!): Order
}

type Order {
  id: ID!
  status: String!
  items: [OrderItem!]!
}

type OrderItem {
  productId: ID!
  quantity: Int!
}
```

El esquema es:

- el contrato
    
- la frontera de lo permitido
    
- la documentación viva
    

---

#### A6.6.2 Resolvers

Los **resolvers**:

- ejecutan la lógica real
    
- traducen campos a datos
    
- pueden llamar servicios, DBs, APIs
    

Un resolver se ejecuta **por campo**, no por request completo.

Este detalle es **crítico** para performance.

---

#### A6.6.3 Query execution tree

Una consulta GraphQL se convierte en:

- un árbol de ejecución
    
- múltiples resolvers
    
- posibles llamadas encadenadas
    

Esto permite flexibilidad, pero introduce riesgos.

---

### A6.7 Overfetching y underfetching (el problema original)

#### Overfetching (REST típico)

- el backend envía más datos de los necesarios
    
- desperdicio de ancho de banda
    
- acoplamiento innecesario
    

#### Underfetching

- múltiples requests para completar una vista
    
- latencia acumulada
    
- lógica en el cliente
    

GraphQL resuelve **ambos**, pero introduce otros problemas.

---

### A6.8 El gran riesgo: N+1 en GraphQL

#### Contexto

En GraphQL, una consulta como:

```graphql
{
  orders {
    id
    items {
      productId
    }
  }
}
```

Puede provocar:

- 1 query para orders
    
- N queries para items
    

Esto es el famoso **problema N+1**, amplificado por GraphQL.

---

#### Modelo mental incorrecto

> “GraphQL es eficiente por defecto.”

No lo es.

---

#### Modelo mental correcto

> “GraphQL necesita **optimización explícita**.”

Técnicas comunes:

- batching
    
- caching
    
- data loaders
    
- queries predefinidas
    

---

### A6.9 Seguridad en GraphQL (más compleja que REST)

#### A6.9.1 Problema fundamental

En REST:

- el servidor controla la forma de la respuesta
    

En GraphQL:

- el cliente controla la forma de la consulta
    

Esto abre riesgos:

- consultas profundas
    
- consultas muy anchas
    
- ataques de denegación de servicio
    
- acceso indirecto a datos sensibles
    

---

#### A6.9.2 Estrategias de protección

- limitar profundidad de consultas
    
- limitar complejidad
    
- timeouts de ejecución
    
- autenticación y autorización por campo
    
- whitelisting de queries
    

Un advanced **nunca** expone GraphQL sin límites.

---

### A6.10 Mutations y consistencia

GraphQL **no impone** semántica transaccional.

Mutations:

- pueden disparar múltiples efectos
    
- pueden ser complejas
    
- deben diseñarse con cuidado
    

Modelo correcto:

> Mutations **expresan intención**, no implementación.

---

### A6.11 Subscriptions (GraphQL en tiempo real)

Subscriptions permiten:

- push de datos
    
- eventos en tiempo real
    

Internamente suelen usar:

- WebSocket
    
- Pub/Sub
    
- brokers
    

Son poderosas, pero:

- complejas de escalar
    
- difíciles de asegurar
    
- costosas si se diseñan mal
    

---

### A6.12 Ejemplo correcto (uso apropiado)

Sistema con:

- múltiples clientes
    
- necesidades de datos distintas
    
- fuerte control de esquema
    
- queries optimizadas
    
- límites estrictos
    

GraphQL se usa como:

- capa de agregación
    
- contrato flexible
    
- gateway controlado
    

---

### A6.13 Ejemplo incorrecto

- exponer todo el modelo de dominio
    
- sin límites de consulta
    
- sin control de performance
    
- sin autorización por campo
    

Resultado:

- sistema vulnerable
    
- performance impredecible
    
- deuda técnica grave
    

---

### A6.14 Errores típicos del principiante

- Pensar que GraphQL simplifica el backend
    
- Ignorar N+1
    
- No limitar consultas
    
- No versionar el esquema conceptualmente
    
- Usar GraphQL donde REST era suficiente
    

---

### A6.15 Señales de comprensión real

Sabes que entiendes GraphQL cuando:

- puedes explicar por qué **no** usarlo
    
- sabes diseñar un esquema estable
    
- sabes proteger el runtime
    
- sabes optimizar resolvers
    
- entiendes el costo de la flexibilidad
    

---

### A6.16 Ejercicio práctico (obligatorio)

Diseña una API GraphQL para:

- 3 clientes distintos
    
- queries complejas
    
- necesidad de seguridad fuerte
    

Define:

- esquema base
    
- límites de consulta
    
- estrategia contra N+1
    
- autenticación/autorización
    
- cuándo NO permitirías una query
    

---

## Cierre del BLOQUE A (Protocolos)

Hasta aquí, el **BLOQUE A** cubre:

- límites de REST
    
- WebSocket
    
- Webhooks
    
- gRPC (completo)
    
- Mensajería avanzada
    
- GraphQL
    


# BLOQUE B — Frameworks y Seguridad Avanzada

**Dominio real del framework, seguridad como sistema y legibilidad bajo presión**

---

## B1. Dominio profundo del framework (cuando el framework deja de ser “ayuda” y pasa a ser infraestructura)

---

### B1.1 Contexto: el problema de “sé usar el framework”

En niveles previos, “saber un framework” suele significar:

- saber crear controllers
    
- saber inyectar dependencias
    
- saber configurar endpoints
    
- saber “que funcione”
    

En nivel **ADVANCED**, eso es insuficiente.

El problema real aparece cuando:

- el sistema crece
    
- hay múltiples equipos
    
- hay múltiples módulos
    
- hay errores difíciles de reproducir
    
- hay problemas de performance
    
- hay comportamientos no evidentes
    

Aquí aparece una verdad incómoda:

> **Si no entiendes el ciclo de vida del framework,  
> el framework decide por ti.**

---

### B1.2 Definición extensa: qué significa dominar un framework

Dominar un framework **NO** es:

- conocer todas las anotaciones
    
- memorizar configuraciones
    
- usar “lo recomendado” sin criterio
    

Dominar un framework es:

> **Entender cómo y cuándo el framework crea, conecta, ejecuta y destruye componentes, y qué impacto tiene eso en el sistema.**

Esto incluye:

- ciclo de vida de objetos
    
- scopes
    
- inyección de dependencias
    
- inicialización
    
- manejo de errores
    
- threading
    
- configuración
    
- extensión del framework
    

---

### B1.3 El ciclo de vida (concepto dentro del concepto)

#### B1.3.1 Qué es el ciclo de vida

El **ciclo de vida** es:

- cuándo se crea un componente
    
- cuándo se inicializa
    
- cuándo se usa
    
- cuándo se destruye
    

En frameworks modernos:

- esto **no lo controla el desarrollador**
    
- lo controla el contenedor
    

---

#### B1.3.2 Problema real del ciclo de vida

Si no entiendes el ciclo de vida:

- inicializas cosas demasiado pronto
    
- usas dependencias no listas
    
- guardas estado donde no debes
    
- introduces race conditions
    
- filtras recursos
    

---

### B1.4 Scopes (otro concepto crítico)

#### B1.4.1 Definición

El **scope** define:

- cuántas instancias existen
    
- cuánto viven
    
- quién las comparte
    

Ejemplos típicos:

- singleton
    
- request
    
- session
    
- prototype
    

---

#### B1.4.2 Modelo mental incorrecto

> “Singleton es más eficiente.”

Esto lleva a:

- estado compartido
    
- problemas de concurrencia
    
- bugs intermitentes
    

---

#### B1.4.3 Modelo mental correcto (ADVANCED)

> “El scope define **riesgo y responsabilidad**, no solo eficiencia.”

Un advanced:

- minimiza estado compartido
    
- entiende concurrencia
    
- usa scopes conscientemente
    

---

### B1.5 Inyección de dependencias (más allá del @Inject)

#### B1.5.1 Qué es realmente DI

Inyección de dependencias no es:

- magia
    
- anotaciones
    
- comodidad
    

Es:

> **Un patrón para desacoplar la creación de objetos de su uso, permitiendo sustitución, testeo y evolución.**

---

#### B1.5.2 Error común del principiante

- inyectar todo
    
- depender del contenedor para todo
    
- no poder crear clases sin framework
    

---

#### B1.5.3 Modelo mental correcto

> “El framework **ensambla**, pero el diseño lo hago yo.”

Un advanced:

- puede crear sus objetos sin el framework
    
- usa DI como infraestructura, no como muleta
    

---

### B1.6 Configuración: explícita vs implícita

#### B1.6.1 Problema de la configuración implícita

Frameworks modernos:

- auto-configuran mucho
    
- hacen “lo correcto” por defecto
    

Esto es cómodo, pero peligroso.

---

#### B1.6.2 Riesgos reales

- no sabes qué está activo
    
- no sabes qué cambió entre versiones
    
- comportamiento inesperado en producción
    

---

#### B1.6.3 Modelo mental correcto

> “Prefiero configuración explícita cuando el impacto es alto.”

El advanced:

- revisa defaults
    
- documenta decisiones
    
- fija comportamientos críticos
    

---

### B1.7 Legibilidad del código en frameworks grandes

#### B1.7.1 Contexto

En sistemas grandes:

- el código se lee más de lo que se escribe
    
- muchas personas lo tocan
    
- los errores cuestan caro
    

---

#### B1.7.2 Qué rompe la legibilidad

- exceso de anotaciones
    
- abstracciones innecesarias
    
- magia implícita
    
- convenciones no documentadas
    

---

#### B1.7.3 Modelo mental correcto

> “El código debe poder entenderse **sin conocer el framework a fondo**.”

Eso:

- reduce errores
    
- facilita onboarding
    
- permite refactor seguro
    

---

### B1.8 Ejemplo correcto

Un módulo donde:

- el dominio es framework-agnóstico
    
- el framework vive en los bordes
    
- las decisiones están explícitas
    
- el ciclo de vida es claro
    

---

### B1.9 Ejemplo incorrecto

- lógica de negocio en annotations
    
- dependencias implícitas
    
- clases imposibles de instanciar sin framework
    

---

### B1.10 Errores típicos del principiante avanzado

- confiar ciegamente en el framework
    
- no leer documentación de bajo nivel
    
- no entender threading
    
- no entender lifecycle hooks
    
- no entender cómo se inicializa el sistema
    

---

### B1.11 Señales de comprensión real

Sabes que dominas un framework cuando:

- puedes explicar su ciclo de vida
    
- puedes predecir qué pasa en producción
    
- puedes depurar sin “probar cosas”
    
- puedes decidir cuándo no usarlo
    

---

### B1.12 Ejercicio práctico

Toma tu framework principal y responde:

- ¿cuándo se crean los componentes?
    
- ¿qué scope usan por defecto?
    
- ¿qué estado comparten?
    
- ¿qué se inicializa al arrancar?
    
- ¿qué se destruye al apagar?
    

---


## B2. Seguridad avanzada — Autenticación, autorización y JWT desarmado

---

### B2.1 Contexto: por qué la seguridad deja de ser “configuración”

En niveles previos, la seguridad suele verse como:

- “poner login”
    
- “proteger endpoints”
    
- “usar JWT”
    
- “activar HTTPS”
    

En **ADVANCED**, esa visión es peligrosa.

La realidad es que:

- los sistemas están expuestos
    
- los ataques son constantes
    
- los errores no siempre son obvios
    
- una mala decisión puede comprometer todo el sistema
    

Aquí aparece una verdad central:

> **La seguridad no es una feature,  
> es una propiedad emergente del diseño.**

---

### B2.2 Definición extensa: qué es seguridad en backend avanzado

Seguridad no es solo:

- autenticación
    
- autorización
    
- cifrado
    

Seguridad es:

> **El conjunto de mecanismos, decisiones y límites que definen  
> quién puede hacer qué, cuándo, cómo y bajo qué condiciones,  
> incluso cuando el sistema está bajo ataque.**

Incluye:

- identidad
    
- confianza
    
- fronteras
    
- validación
    
- observabilidad
    
- reacción ante fallos
    

---

### B2.3 Autenticación vs Autorización (desarmado completamente)

#### B2.3.1 Autenticación

**Definición**

> Verificar **quién** es el actor.

Ejemplos:

- usuario
    
- servicio
    
- dispositivo
    

Autenticación responde a:

> “¿Quién eres?”

---

#### B2.3.2 Autorización

**Definición**

> Determinar **qué puede hacer** ese actor.

Responde a:

> “¿Qué tienes permitido hacer?”

---

#### B2.3.3 Error crítico del principiante

Confundir ambos conceptos.

Resultado:

- accesos indebidos
    
- reglas rotas
    
- seguridad falsa
    

---

### B2.4 Modelo mental incorrecto

> “Si el usuario está autenticado, puede hacer cosas.”

Esto es **falso**.

---

### B2.5 Modelo mental correcto (ADVANCED)

> “La autenticación abre la puerta;  
> la autorización decide hasta dónde puede caminar.”

Un advanced separa claramente:

- identidad
    
- permisos
    
- contexto
    

---

### B2.6 JWT desarmado completamente (conceptos dentro del concepto)

---

#### B2.6.1 Qué es realmente un JWT

JWT (JSON Web Token) es:

> **Un token autocontenido firmado que transporta claims sobre una identidad.**

No es:

- una sesión
    
- un permiso en sí mismo
    
- un mecanismo mágico de seguridad
    

---

#### B2.6.2 Estructura interna de un JWT

Un JWT tiene tres partes:

1. **Header**
    
    - algoritmo de firma
        
    - tipo de token
        
2. **Payload (claims)**
    
    - identidad
        
    - metadata
        
    - expiración
        
    - scopes/roles
        
3. **Signature**
    
    - garantiza integridad
        
    - no confidencialidad
        

---

#### B2.6.3 Error común: confundir firma con cifrado

La firma:

- evita modificación
    
- **no oculta contenido**
    

Cualquiera puede leer el payload.

---

### B2.7 Claims: qué son y qué no son

#### B2.7.1 Qué son claims

Claims son:

- afirmaciones
    
- datos declarativos
    
- información firmada
    

Ejemplos:

- `sub`
    
- `exp`
    
- `iss`
    
- `aud`
    
- `roles`
    

---

#### B2.7.2 Qué NO deben ser claims

- reglas de negocio complejas
    
- permisos dinámicos
    
- información sensible
    
- estados cambiantes
    

---

### B2.8 Expiración y renovación (punto crítico)

#### B2.8.1 Por qué expirar tokens

Un token que no expira:

- es un riesgo permanente
    
- no se puede revocar fácilmente
    

---

#### B2.8.2 Access token vs Refresh token

Modelo correcto:

- **Access token**: corto, frecuente
    
- **Refresh token**: más largo, más protegido
    

El advanced diseña:

- ciclos de renovación
    
- revocación
    
- rotación de tokens
    

---

### B2.9 Revocación: el gran problema de JWT

JWT es **stateless**.

Eso implica:

- no hay sesión central
    
- no hay invalidación inmediata
    

Estrategias:

- expiraciones cortas
    
- listas de revocación
    
- rotación de claves
    
- introspección
    

Cada una tiene trade-offs.

---

### B2.10 Seguridad entre servicios (microservicios)

#### B2.10.1 Problema real

En sistemas distribuidos:

- los servicios también se autentican
    
- no solo los usuarios
    

---

#### B2.10.2 Enfoques comunes

- mTLS
    
- tokens de servicio
    
- identidades gestionadas
    
- trust boundaries claras
    

---

### B2.11 Modelo de confianza (trust boundaries)

Un sistema advanced:

- define fronteras de confianza
    
- no asume que todo es confiable
    
- valida en cada frontera
    

Ejemplo:

- internet → API Gateway
    
- gateway → servicios internos
    
- servicios → base de datos
    

Cada frontera tiene reglas distintas.

---

### B2.12 Ejemplo correcto (diseño conceptual)

Sistema con:

- gateway que autentica usuarios
    
- servicios internos que validan tokens
    
- autorización contextual
    
- tokens con expiración corta
    
- mTLS entre servicios
    

---

### B2.13 Ejemplo incorrecto

- JWT con expiración de meses
    
- claims con reglas de negocio
    
- confiar en el token sin validación
    
- no validar `aud` o `iss`
    

Resultado:

- accesos indebidos
    
- escaladas de privilegios
    
- incidentes graves
    

---

### B2.14 Errores típicos del principiante

- Tokens eternos
    
- Tokens con demasiada información
    
- No validar firma
    
- No validar audiencia
    
- Mezclar autenticación y autorización
    
- No auditar accesos
    

---

### B2.15 Señales de comprensión real

Sabes que entiendes seguridad avanzada cuando:

- puedes explicar un flujo completo de auth
    
- puedes justificar expiraciones
    
- puedes describir trust boundaries
    
- puedes explicar cómo se revoca acceso
    
- sabes qué información **no** debe ir en un token
    

---

### B2.16 Ejercicio práctico (obligatorio)

Diseña un sistema de autenticación para:

- usuarios web
    
- microservicios internos
    
- tokens con renovación
    
- revocación ante incidente
    

Define:

- tipos de tokens
    
- expiraciones
    
- trust boundaries
    
- cómo reaccionas ante compromiso
    

---

## B3. Antipatrones de seguridad y framework en sistemas ADVANCED

_(lo que rompe sistemas reales aunque “todo funcione”)_

---

### B3.1 Contexto: por qué los antipatrones son más peligrosos que los bugs

En nivel ADVANCED, la mayoría de caídas graves **no** ocurren por:

- errores de sintaxis
    
- fallos obvios
    
- código que “no compila”
    

Ocurren por:

- **decisiones aparentemente razonables**
    
- **atajos bien intencionados**
    
- **configuraciones copiadas**
    
- **suposiciones falsas**
    

Aquí aparece una verdad dura:

> **Un antipatrón no falla siempre.  
> Falla cuando más duele.**

---

## B3.2 Antipatrones de Framework (Spring / similares)

---

### B3.2.1 Antipatrón: “El framework decide todo”

#### Contexto

Frameworks modernos:

- auto-configuran
    
- infieren
    
- asumen convenciones
    

Esto da velocidad inicial, pero…

---

#### Definición del antipatrón

> **Delegar decisiones arquitectónicas críticas al comportamiento por defecto del framework, sin entenderlas ni documentarlas.**

---

#### Ejemplo típico

- Datasource configurado automáticamente
    
- Pool de conexiones por defecto
    
- Timeouts implícitos
    
- Serialización automática sin control
    

---

#### Por qué está mal

- Cambios de versión alteran comportamientos
    
- Producción se comporta distinto a local
    
- Debug se vuelve reactivo, no predictivo
    

---

#### Modelo mental incorrecto

> “Si el framework lo hace, debe estar bien.”

---

#### Modelo mental correcto (ADVANCED)

> “El framework **ejecuta decisiones**, pero **yo las tomo**.”

---

#### Error típico del principiante

- No leer defaults
    
- No fijar valores críticos
    
- No documentar decisiones
    

---

#### Señales de comprensión

- Puedes listar defaults activos
    
- Puedes explicar por qué los aceptas o cambias
    
- Puedes predecir efectos de upgrades
    

---

#### Ejercicio

Identifica en tu framework:

- 5 configuraciones críticas que hoy están por defecto
    
- decide explícitamente si deben seguir así
    

---

### B3.2.2 Antipatrón: Lógica de negocio en anotaciones

#### Contexto

Anotaciones son cómodas:

- `@Transactional`
    
- `@Secured`
    
- `@Cacheable`
    

Pero mal usadas…

---

#### Definición

> **Esconder reglas de negocio, flujos críticos o decisiones funcionales dentro de anotaciones.**

---

#### Ejemplo incorrecto

- Autorización de negocio en `@PreAuthorize`
    
- Transacciones que definen lógica
    
- Caché aplicada sin entender consistencia
    

---

#### Por qué está mal

- El flujo real no es visible en el código
    
- El orden de ejecución es implícito
    
- El comportamiento cambia sin tocar código
    

---

#### Modelo mental incorrecto

> “Menos código = mejor diseño.”

---

#### Modelo mental correcto

> “La lógica crítica debe ser **explícita y legible**.”

---

#### Errores comunes

- No saber cuándo inicia una transacción
    
- No saber cuándo se hace rollback
    
- No saber cuándo se invalida caché
    

---

#### Ejercicio

Revisa un servicio y responde:

- ¿qué pasaría si quito todas las anotaciones?
    
- ¿seguiría siendo comprensible el flujo?
    

---

### B3.2.3 Antipatrón: Singleton con estado mutable

#### Contexto

La mayoría de beans son singletons.

---

#### Definición

> **Guardar estado mutable en componentes compartidos entre múltiples hilos.**

---

#### Ejemplo

- Contadores en memoria
    
- Listas acumulativas
    
- Cache manual sin sincronización
    

---

#### Por qué está mal

- Condiciones de carrera
    
- Bugs intermitentes
    
- Comportamiento no determinista
    

---

#### Modelo mental incorrecto

> “Si no falla local, no falla.”

---

#### Modelo mental correcto

> “Todo singleton es compartido;  
> todo lo compartido es peligroso.”

---

#### Ejercicio

Busca en tu código:

- cualquier campo no inmutable en singletons
    
- evalúa riesgo real
    

---

## B3.3 Antipatrones de Seguridad (los más peligrosos)

---

### B3.3.1 Antipatrón: “JWT como permiso”

#### Definición

> **Asumir que si el JWT contiene algo, entonces está autorizado.**

---

#### Ejemplo incorrecto

- `role=ADMIN` en el token → acceso total
    
- reglas de negocio basadas solo en claims
    

---

#### Por qué está mal

- El token puede estar desactualizado
    
- Los permisos cambian
    
- El contexto importa
    

---

#### Modelo mental correcto

> “JWT prueba identidad,  
> no autoriza decisiones complejas.”

---

### B3.3.2 Antipatrón: Tokens eternos

#### Definición

> **Tokens con expiraciones largas o sin expiración.**

---

#### Impacto real

- Robo de token = acceso prolongado
    
- Revocación imposible
    
- Incidentes graves
    

---

#### Ejemplo típico

- `exp = +6 meses`
    
- `remember me` mal diseñado
    

---

#### Modelo mental correcto

> “Un token es una bomba de tiempo.”

---

### B3.3.3 Antipatrón: Confiar en el frontend

#### Definición

> **Asumir que el frontend valida correctamente y no necesita revalidación backend.**

---

#### Ejemplos

- Validaciones solo en JS
    
- Autorización implícita por UI
    
- Endpoints “no expuestos”
    

---

#### Por qué está mal

- El atacante no usa tu frontend
    
- El backend es la última frontera
    

---

### B3.3.4 Antipatrón: Seguridad solo en el gateway

#### Definición

> **Autenticar y autorizar solo en el API Gateway y no en servicios internos.**

---

#### Impacto

- Ataques laterales
    
- Acceso interno indebido
    
- Violación de trust boundaries
    

---

#### Modelo mental correcto

> “Cada frontera valida;  
> ninguna confía ciegamente.”

---

## B3.4 Antipatrones combinados (los más reales)

---

### B3.4.1 Framework + Seguridad

Ejemplo real:

- `@PreAuthorize` con lógica compleja
    
- roles en JWT
    
- sin validación contextual
    
- transacción automática
    

Resultado:

- reglas invisibles
    
- bugs de seguridad
    
- difícil auditoría
    

---

### B3.4.2 Observabilidad ausente

Antipatrón:

- seguridad sin logs
    
- sin trazas
    
- sin métricas
    

Resultado:

- incidentes sin explicación
    
- tiempo de respuesta lento
    
- pérdida de confianza
    

---

## B3.5 Señales de madurez real (ADVANCED)

Sabes que dominas este bloque cuando:

- puedes **predecir** fallos
    
- puedes explicar **por qué** algo es peligroso
    
- puedes rechazar “soluciones fáciles”
    
- puedes defender decisiones ante auditoría
    
- puedes dormir tranquilo tras un deploy
    

---

## B3.6 Ejercicio integrador

Audita mentalmente un sistema real y responde:

1. ¿Dónde confía de más?
    
2. ¿Qué decisiones están implícitas?
    
3. ¿Qué pasaría si un token se filtra?
    
4. ¿Qué componente es single point of failure?
    
5. ¿Qué antipatrón te preocupa más?
    

---


# BLOQUE C — SQL / RDBMS Avanzado

**Transacciones reales, ACID verdadero, aislamiento, locks, deadlocks y performance bajo carga**

---

## C1. Transacciones en sistemas reales (no el ejemplo académico)

---

### C1.1 Contexto: por qué las transacciones se vuelven críticas en ADVANCED

En niveles previos, una transacción suele verse como:

- “BEGIN”
    
- “COMMIT”
    
- “ROLLBACK”
    
- “si algo falla, se deshace”
    

Ese modelo **es insuficiente** en sistemas reales.

En nivel **ADVANCED**, aparecen problemas como:

- múltiples transacciones concurrentes
    
- múltiples servicios accediendo a la misma base
    
- operaciones largas
    
- bloqueos inesperados
    
- degradación progresiva del sistema
    
- errores intermitentes imposibles de reproducir
    

Aquí aparece una verdad clave:

> **Una transacción no es solo atomicidad;  
> es una negociación con otros procesos concurrentes.**

---

### C1.2 Definición extensa: qué es realmente una transacción

Una **transacción** es:

> **Una unidad lógica de trabajo que agrupa múltiples operaciones sobre una base de datos, garantizando propiedades de consistencia bajo concurrencia, fallos y recuperación.**

Desarmemos la definición:

- **Unidad lógica**  
    No es solo una instrucción, es una intención.
    
- **Múltiples operaciones**  
    Reads, writes, locks, checks.
    
- **Consistencia bajo concurrencia**  
    Otras transacciones existen al mismo tiempo.
    
- **Fallos**  
    El sistema puede caer en cualquier momento.
    
- **Recuperación**  
    El sistema debe volver a un estado válido.
    

---

### C1.3 Qué pasaba antes de transacciones robustas

Antes:

- operaciones sueltas
    
- estados intermedios visibles
    
- corrupción de datos
    
- reglas violadas
    

Las transacciones surgen para:

- proteger invariantes
    
- asegurar coherencia
    
- permitir recuperación automática
    

---

### C1.4 Modelo mental incorrecto (muy común)

> “Una transacción es solo un bloque try/catch en la base de datos.”

Este modelo mental lleva a:

- transacciones gigantes
    
- locks prolongados
    
- degradación severa
    
- deadlocks frecuentes
    

---

### C1.5 Modelo mental correcto (ADVANCED)

> “Una transacción es un **acuerdo temporal** entre procesos concurrentes para proteger invariantes.”

Un advanced entiende que:

- toda transacción compite
    
- toda transacción tiene costo
    
- toda transacción afecta a otras
    

---

## C2. ACID desarmado de verdad (no el acrónimo memorizado)

---

### C2.1 Atomicidad (A)

#### Definición real

Atomicidad significa:

> **O todo el conjunto de operaciones se aplica,  
> o ninguna deja efectos observables.**

No significa:

- “no hay efectos internos”
    
- “no hubo locks”
    
- “no hubo trabajo”
    

---

#### Error típico del principiante

- pensar que atomicidad evita estados intermedios internos
    
- olvidar que los locks sí ocurren
    

---

#### Modelo correcto

> “Atomicidad protege el resultado,  
> no el proceso.”

---

### C2.2 Consistencia (C)

#### Definición correcta

Consistencia significa:

> **La transacción lleva la base de datos de un estado válido a otro estado válido según las reglas definidas.**

Punto crítico:

- la base **no conoce** tus reglas de negocio
    
- tú defines qué es “válido”
    

---

#### Error común

- asumir que la base “cuida la lógica”
    
- no definir constraints
    
- confiar solo en código
    

---

### C2.3 Aislamiento (I) — el punto más complejo

Aislamiento define:

> **Qué tan visibles son los efectos de una transacción para otras transacciones concurrentes.**

Aquí ocurren:

- lecturas sucias
    
- lecturas no repetibles
    
- phantom reads
    

Este es el **corazón del diseño avanzado**.

---

### C2.4 Durabilidad (D)

Durabilidad significa:

> **Una vez confirmado, el cambio sobrevivirá a fallos del sistema.**

Implica:

- logs de transacciones
    
- fsync
    
- escritura en disco
    
- replicación
    

Trade-off:

- durabilidad fuerte = más latencia
    

---

## C3. Niveles de aislamiento (desarmados uno por uno)

---

### C3.1 READ UNCOMMITTED

- Permite lecturas sucias
    
- Rara vez usado
    
- Muy rápido
    
- Muy peligroso
    

Modelo mental:

> “Ver cosas que nunca existieron.”

---

### C3.2 READ COMMITTED

- No lee datos no confirmados
    
- Puede leer datos distintos en la misma transacción
    

Problema:

- lecturas no repetibles
    

Es el default en muchos RDBMS.

---

### C3.3 REPEATABLE READ

- Los datos leídos no cambian
    
- Aún puede haber phantoms
    

Costo:

- más locks
    
- menos concurrencia
    

---

### C3.4 SERIALIZABLE

- Simula ejecución secuencial
    
- Máxima consistencia
    
- Máximo costo
    

No escala bien en alta concurrencia.

---

### C3.5 Modelo mental incorrecto

> “SERIALIZABLE es siempre mejor.”

Esto destruye performance.

---

### C3.6 Modelo mental correcto (ADVANCED)

> “Elijo el aislamiento **mínimo** que protege mis invariantes.”

---

## C4. Locks: el mecanismo oculto

---

### C4.1 Qué es un lock

Un lock es:

> **Un mecanismo de coordinación que impide operaciones conflictivas sobre recursos compartidos.**

Tipos:

- row-level
    
- table-level
    
- shared
    
- exclusive
    

---

### C4.2 Locks implícitos vs explícitos

- Implícitos: el motor decide
    
- Explícitos: el desarrollador fuerza
    

Usar locks explícitos:

- es poderoso
    
- es peligroso
    

---

### C4.3 Problema real de locks

- no visibles fácilmente
    
- se acumulan
    
- se propagan
    
- generan cascadas
    

---

### C4.4 Errores típicos

- transacciones largas
    
- operaciones de IO dentro de transacciones
    
- llamadas externas dentro de transacciones
    
- locks más amplios de lo necesario
    

---

## C5. Deadlocks (inevitables pero manejables)

---

### C5.1 Qué es un deadlock

Deadlock ocurre cuando:

- T1 espera un recurso de T2
    
- T2 espera un recurso de T1
    
- nadie puede avanzar
    

---

### C5.2 Verdad incómoda

> **Los deadlocks no se eliminan;  
> se detectan y se manejan.**

---

### C5.3 Estrategias reales

- orden consistente de acceso
    
- transacciones pequeñas
    
- reintentos controlados
    
- detección temprana
    

---

### C5.4 Error común

- “Nunca nos pasa”
    
- no manejar el error
    
- no reintentar
    

Resultado:

- fallos en producción
    

---

## C6. Performance bajo carga (donde todo se rompe)

---

### C6.1 Problema clásico

Sistema funciona bien:

- con pocos usuarios
    
- con datos pequeños
    

Bajo carga:

- locks largos
    
- latencia
    
- timeouts
    
- caída parcial
    

---

### C6.2 Antipatrones de performance

- transacciones enormes
    
- `SELECT *`
    
- índices inexistentes
    
- joins innecesarios
    
- lógica en la base sin criterio
    

---

### C6.3 Modelo mental correcto

> “La base de datos es un recurso compartido y finito.”

---

## C7. Errores típicos del principiante avanzado

- creer que ACID es gratis
    
- ignorar aislamiento
    
- usar SERIALIZABLE por miedo
    
- no medir
    
- no observar locks
    

---

## C8. Señales de comprensión real

Sabes que entiendes SQL avanzado cuando:

- puedes explicar un deadlock
    
- puedes justificar aislamiento
    
- puedes predecir locks
    
- puedes explicar degradación bajo carga
    

---

## C9. Ejercicio práctico (obligatorio)

Diseña una operación de negocio crítica y responde:

- ¿qué transacciones involucra?
    
- ¿qué aislamiento necesitas?
    
- ¿qué locks se toman?
    
- ¿qué pasa si hay 1000 concurrentes?
    
- ¿qué pasa si ocurre un deadlock?
    

---


## C10. Antipatrones de bases de datos en backend avanzado

_(cuando la base “funciona” pero el sistema muere)_

---

### C10.1 Contexto: por qué los antipatrones de BD son silenciosos

Los antipatrones de base de datos son especialmente peligrosos porque:

- el sistema **no falla de inmediato**
    
- los tests pasan
    
- el rendimiento inicial es bueno
    
- los datos “se ven correctos”
    

El daño aparece cuando:

- crece el volumen
    
- crece la concurrencia
    
- cambian los casos de uso
    
- el negocio exige más
    

Verdad incómoda:

> **Un antipatrón de BD puede tardar meses en manifestarse,  
> pero cuando lo hace, el costo es altísimo.**

---

## C10.2 Antipatrones de modelado de datos

---

### C10.2.1 Antipatrón: Modelo orientado al código, no al dominio

#### Definición

> **Diseñar tablas copiando directamente las clases del código sin analizar el dominio ni las invariantes.**

---

#### Contexto real

Esto ocurre cuando:

- se usa ORM sin criterio
    
- se “mapea” clase → tabla
    
- se ignoran relaciones reales
    

---

#### Por qué está mal

- el modelo refleja implementación, no negocio
    
- cambios de código rompen datos
    
- queries complejas se vuelven imposibles
    

---

#### Modelo mental incorrecto

> “Si mi clase existe, mi tabla debe existir.”

---

#### Modelo mental correcto (ADVANCED)

> “La base representa **el dominio**,  
> el código se adapta a la base.”

---

#### Errores típicos

- tablas con demasiadas columnas
    
- relaciones implícitas
    
- datos duplicados
    
- invariantes no representadas
    

---

#### Ejercicio

Elige una entidad y responde:

- ¿qué invariantes protege?
    
- ¿cuáles no están representadas en la BD?
    

---

### C10.2.2 Antipatrón: Denormalización temprana

#### Definición

> **Duplicar datos sin una necesidad real de performance.**

---

#### Contexto

Se hace para:

- “optimizar”
    
- evitar joins
    
- acelerar queries simples
    

---

#### Por qué está mal

- inconsistencias
    
- lógica de sincronización
    
- bugs sutiles
    
- mantenimiento complejo
    

---

#### Modelo mental correcto

> “Primero consistencia,  
> luego optimización medida.”

---

### C10.2.3 Antipatrón: Claves artificiales sin criterio

#### Definición

> **Usar IDs artificiales ignorando claves naturales del dominio.**

---

#### Problema

- se pierde semántica
    
- se permiten duplicados lógicos
    
- reglas de negocio se rompen
    

---

#### Modelo correcto

Un advanced:

- evalúa claves naturales
    
- combina con surrogate keys si es necesario
    
- protege unicidad real con constraints
    

---

## C10.3 Antipatrones de transacciones

---

### C10.3.1 Antipatrón: Transacciones gigantes

#### Definición

> **Encerrar demasiada lógica dentro de una sola transacción.**

---

#### Ejemplo típico

- llamadas externas dentro de la transacción
    
- múltiples operaciones no relacionadas
    
- lógica de negocio extensa
    

---

#### Impacto

- locks prolongados
    
- deadlocks
    
- timeouts
    
- degradación global
    

---

#### Modelo mental correcto

> “Una transacción debe ser  
> lo más corta posible y no más.”

---

---

### C10.3.2 Antipatrón: Transacciones implícitas sin saberlo

#### Definición

> **No saber cuándo inicia y termina una transacción.**

---

#### Contexto

Ocurre con:

- ORMs
    
- anotaciones automáticas
    
- frameworks mágicos
    

---

#### Por qué está mal

- commits inesperados
    
- rollbacks tardíos
    
- estado inconsistente
    

---

#### Señal de riesgo

Si no puedes responder:

- ¿dónde empieza?
    
- ¿dónde termina?
    

entonces hay un antipatrón.

---

## C10.4 Antipatrones de concurrencia

---

### C10.4.1 Antipatrón: Ignorar el aislamiento

#### Definición

> **Confiar en el aislamiento por defecto sin entenderlo.**

---

#### Impacto

- lecturas inconsistentes
    
- errores intermitentes
    
- bugs imposibles de reproducir
    

---

#### Modelo correcto

> “El aislamiento es una decisión de diseño,  
> no un detalle técnico.”

---

### C10.4.2 Antipatrón: SERIALIZABLE por miedo

#### Definición

> **Usar el nivel más alto “por seguridad”.**

---

#### Impacto

- throughput bajo
    
- locks excesivos
    
- colas implícitas
    
- caída bajo carga
    

---

#### Modelo correcto

> “Uso el aislamiento mínimo que protege mis invariantes.”

---

## C10.5 Antipatrones de performance

---

### C10.5.1 Antipatrón: SELECT *

#### Definición

> **Traer más datos de los necesarios.**

---

#### Impacto

- IO innecesario
    
- memoria
    
- latencia
    
- uso de red
    

---

#### Modelo correcto

> “Traigo exactamente lo que necesito,  
> nada más.”

---

### C10.5.2 Antipatrón: Índices sin criterio

#### Definición

> **Crear índices “por si acaso”.**

---

#### Impacto

- escrituras más lentas
    
- consumo de disco
    
- planes de ejecución peores
    

---

#### Modelo correcto

> “Cada índice tiene un propósito medido.”

---

### C10.5.3 Antipatrón: Lógica compleja en la base sin control

#### Definición

> **Mover lógica al RDBMS sin diseño ni pruebas.**

---

#### Riesgos

- dependencia fuerte
    
- dificultad de testing
    
- bloqueo tecnológico
    
- debugging complejo
    

---

## C10.6 Antipatrones ORM (JPA/Hibernate-style)

---

### C10.6.1 Antipatrón: N+1 Queries

#### Definición

> **Disparar una query por cada entidad relacionada.**

---

#### Impacto

- explosión de queries
    
- latencia
    
- consumo de CPU
    

---

#### Modelo correcto

- fetch strategies claras
    
- joins controlados
    
- batch loading
    

---

### C10.6.2 Antipatrón: Cascadas indiscriminadas

#### Definición

> **Usar cascadas sin entender impacto.**

---

#### Impacto

- borrados accidentales
    
- escrituras masivas
    
- efectos colaterales
    

---

---

## C10.7 Señales de comprensión real (ADVANCED)

Sabes que entiendes antipatrones de BD cuando:

- puedes anticipar problemas bajo carga
    
- puedes explicar por qué algo “rápido” es peligroso
    
- puedes defender un diseño ante crecimiento
    
- sabes cuándo decir “no” a optimizaciones prematuras
    

---

## C10.8 Ejercicio integrador

Audita una base real y responde:

1. ¿Qué antipatrones ves?
    
2. ¿Cuál es el más peligroso a largo plazo?
    
3. ¿Qué cambiarías primero?
    
4. ¿Qué medirías antes de optimizar?
    
5. ¿Qué deuda aceptarías conscientemente?
    

---


# BLOQUE D — Concurrencia y Paralelismo Real

**Procesos, hilos, event loop, bloqueos, starvation y errores sistémicos**

---

## D1. Contexto: por qué la concurrencia es inevitable en backend avanzado

En sistemas simples:

- una petición
    
- un hilo
    
- una respuesta
    

En sistemas **ADVANCED**:

- miles de peticiones concurrentes
    
- múltiples núcleos
    
- servicios distribuidos
    
- IO lento
    
- CPU compartida
    

Aquí aparece una verdad clave:

> **La concurrencia no es una optimización;  
> es una condición natural del sistema.**

Ignorarla no evita problemas: **los garantiza**.

---

## D2. Definiciones fundamentales (desarmadas desde cero)

---

### D2.1 Proceso

#### Definición

Un **proceso** es:

> **Una instancia de un programa en ejecución con su propio espacio de memoria y recursos.**

Características:

- aislamiento fuerte
    
- comunicación costosa
    
- mayor consumo de recursos
    
- mayor seguridad
    

---

#### Modelo mental incorrecto

> “Un proceso es solo un programa corriendo.”

---

#### Modelo mental correcto

> “Un proceso es una **unidad de aislamiento**, no solo de ejecución.”

---

### D2.2 Hilo (Thread)

#### Definición

Un **hilo** es:

> **Una unidad de ejecución dentro de un proceso que comparte memoria y recursos con otros hilos del mismo proceso.**

Características:

- compartición de memoria
    
- comunicación rápida
    
- riesgo alto de errores
    
- bajo costo relativo
    

---

#### Modelo mental incorrecto

> “Más hilos = más rápido.”

---

#### Modelo mental correcto (ADVANCED)

> “Más hilos = más **complejidad**.”

---

### D2.3 Concurrencia vs Paralelismo (distinción crítica)

#### Concurrencia

> **Múltiples tareas progresan en el tiempo, aunque no necesariamente al mismo tiempo.**

- alternancia
    
- intercalado
    
- coordinación
    

---

#### Paralelismo

> **Múltiples tareas se ejecutan exactamente al mismo tiempo en distintos núcleos.**

- ejecución real simultánea
    
- depende del hardware
    

---

#### Error típico del principiante

Usar ambos términos como sinónimos.

---

#### Modelo mental correcto

> “Concurrencia es estructura;  
> paralelismo es capacidad.”

---

## D3. Problemas clásicos de concurrencia (los que rompen sistemas)

---

### D3.1 Condiciones de carrera (Race Conditions)

#### Definición

Una **race condition** ocurre cuando:

> **El resultado depende del orden de ejecución de hilos concurrentes.**

---

#### Ejemplo conceptual

- dos hilos leen el mismo valor
    
- ambos lo modifican
    
- uno pisa al otro
    

Resultado:

- estado inconsistente
    
- bug intermitente
    

---

#### Por qué es peligrosa

- no siempre ocurre
    
- no siempre se reproduce
    
- aparece bajo carga
    

---

### D3.2 Estado compartido mutable (el enemigo principal)

#### Definición

> **Datos que pueden ser modificados por múltiples hilos.**

Ejemplos:

- variables globales
    
- singletons con estado
    
- caches en memoria
    

---

#### Modelo mental correcto

> “Si es mutable y compartido,  
> es una fuente de bugs.”

---

### D3.3 Bloqueos (Locks)

#### Definición

Un **lock** es:

> **Un mecanismo que impide que múltiples hilos accedan simultáneamente a un recurso crítico.**

---

#### Tipos conceptuales

- mutex
    
- semáforos
    
- locks reentrantes
    
- read/write locks
    

---

#### Problema real

Los locks:

- resuelven problemas
    
- crean otros nuevos
    

---

### D3.4 Deadlock en concurrencia

#### Definición

Deadlock ocurre cuando:

- Hilo A espera a B
    
- B espera a A
    
- ninguno avanza
    

---

#### Verdad incómoda

> **Los deadlocks no se eliminan,  
> se reducen y se manejan.**

---

### D3.5 Starvation

#### Definición

> **Un hilo nunca obtiene recursos porque otros siempre se adelantan.**

Resultado:

- tareas nunca ejecutadas
    
- latencia infinita
    

---

## D4. Modelos de concurrencia (cómo enfrentan el problema)

---

### D4.1 Modelo basado en locks

- sincronización explícita
    
- control manual
    
- alto riesgo
    

Ventaja:

- flexible
    

Desventaja:

- propenso a errores
    

---

### D4.2 Modelo inmutable

- no se modifica estado
    
- se crean nuevos valores
    
- comunicación por mensajes
    

Ventaja:

- seguro
    
- predecible
    

Costo:

- memoria
    
- diseño
    

---

### D4.3 Actor Model

#### Definición

> **Cada actor encapsula estado y se comunica solo por mensajes.**

Características:

- sin estado compartido
    
- procesamiento secuencial interno
    
- alta escalabilidad
    

---

#### Modelo mental correcto

> “No comparto memoria;  
> comparto mensajes.”

---

### D4.4 Event Loop (Node.js y similares)

#### Contexto

Node.js no usa hilos por request.

---

#### Definición

> **Un bucle que procesa eventos de manera no bloqueante, delegando operaciones costosas a subsistemas.**

---

#### Error típico

- operaciones bloqueantes en el event loop
    

Resultado:

- todo el sistema se congela
    

---

#### Modelo correcto

> “El event loop debe permanecer libre.”

---

## D5. Concurrencia en backend real (casos típicos)

---

### D5.1 IO vs CPU

- IO: esperar red, disco
    
- CPU: cálculo intensivo
    

Modelo correcto:

- no bloquear IO
    
- aislar CPU
    

---

### D5.2 Pools de hilos

Pools:

- limitan concurrencia
    
- protegen recursos
    

Error común:

- pools muy grandes
    
- pools sin límites
    

---

### D5.3 Backpressure en concurrencia

Si produces más tareas de las que consumes:

- la cola crece
    
- la memoria crece
    
- el sistema cae
    

---

## D6. Antipatrones de concurrencia (muy reales)

---

### D6.1 Antipatrón: Sincronizar “por si acaso”

- locks innecesarios
    
- rendimiento pobre
    
- falsa seguridad
    

---

### D6.2 Antipatrón: Estado global compartido

- contadores
    
- caches manuales
    
- flags globales
    

---

### D6.3 Antipatrón: Bloquear en async

- llamadas bloqueantes
    
- espera activa
    
- sleep en event loop
    

---

### D6.4 Antipatrón: Ignorar concurrencia en tests

- tests secuenciales
    
- producción concurrente
    

Resultado:

- bugs tardíos
    

---

## D7. Señales de comprensión real

Sabes que entiendes concurrencia cuando:

- puedes explicar un race condition
    
- puedes justificar un lock
    
- puedes elegir modelo correcto
    
- puedes predecir fallos bajo carga
    

---

## D8. Ejercicio práctico (obligatorio)

Diseña un componente que:

- maneje múltiples peticiones concurrentes
    
- proteja estado crítico
    
- no bloquee IO
    

Define:

- modelo de concurrencia
    
- qué se bloquea
    
- qué no
    
- cómo escalaría
    

---


# BLOQUE E — NoSQL, CAP y BASE en sistemas reales

**Decisiones de consistencia, disponibilidad y particionado bajo presión**

---

## E1. Contexto: por qué NoSQL aparece (y por qué se usa mal)

En sistemas avanzados, los RDBMS comienzan a mostrar límites prácticos cuando:

- el volumen crece de forma no lineal
    
- la latencia debe ser baja globalmente
    
- la distribución geográfica es obligatoria
    
- la elasticidad es prioritaria
    
- la disponibilidad no puede sacrificarse
    

Antes de NoSQL, se intentaba:

- escalar verticalmente
    
- replicar de forma limitada
    
- cachear agresivamente
    
- fragmentar manualmente
    

Estos enfoques funcionan **hasta cierto punto**.

Aparece entonces una verdad incómoda:

> **NoSQL no surge para “reemplazar SQL”,  
> surge para aceptar trade-offs que SQL no acepta.**

---

## E2. Definición extensa: qué es realmente NoSQL

NoSQL **no** significa:

- “no SQL”
    
- “sin estructura”
    
- “sin consistencia”
    

NoSQL significa:

> **Sistemas de almacenamiento diseñados para escalar horizontalmente, priorizando distintos compromisos entre consistencia, disponibilidad y tolerancia a particiones.**

Desarmando la definición:

- **Escala horizontal**  
    Agregar nodos, no potencia.
    
- **Distribución nativa**  
    El sistema asume particiones.
    
- **Trade-offs explícitos**  
    Se renuncia a algo conscientemente.
    

---

## E3. Teorema CAP (desarmado sin simplificaciones)

---

### E3.1 Contexto: el problema fundamental de los sistemas distribuidos

En un sistema distribuido:

- la red falla
    
- los nodos se separan
    
- la latencia varía
    
- los mensajes se pierden
    

CAP no es una regla arbitraria:

> **Es una consecuencia de la física.**

---

### E3.2 Definición del Teorema CAP

El Teorema CAP establece que:

> **Ante una partición de red, un sistema distribuido solo puede garantizar como máximo dos de las siguientes tres propiedades:**
> 
> - **Consistencia (C)**
>     
> - **Disponibilidad (A)**
>     
> - **Tolerancia a particiones (P)**
>     

---

### E3.3 Desarmando cada propiedad

#### Consistencia (C)

> **Todos los nodos ven los mismos datos al mismo tiempo.**

No significa:

- datos “correctos”
    
- reglas de negocio válidas
    

Significa:

- lectura tras escritura coherente
    

---

#### Disponibilidad (A)

> **Cada solicitud recibe una respuesta, incluso ante fallos.**

No garantiza:

- que sea la respuesta más reciente
    

---

#### Tolerancia a particiones (P)

> **El sistema sigue funcionando cuando hay fallos de comunicación entre nodos.**

En sistemas distribuidos reales:

> **P no es opcional.**

---

### E3.4 Error común (muy grave)

> “Mi sistema es CA.”

En presencia de particiones reales, **CA no existe**.

---

### E3.5 Modelo mental correcto (ADVANCED)

> “Cuando hay partición, elijo entre C o A.”

Un advanced:

- diseña para la decisión
    
- comunica el impacto al negocio
    
- no se engaña
    

---

## E4. BASE vs ACID (no son opuestos morales)

---

### E4.1 Qué es BASE

BASE significa:

- **Basically Available**
    
- **Soft state**
    
- **Eventually consistent**
    

No es “peor” que ACID:

> **Es distinto.**

---

### E4.2 Basically Available

El sistema:

- responde
    
- aunque la respuesta no sea la más reciente
    

Prioriza:

- continuidad del servicio
    

---

### E4.3 Soft State

El estado:

- puede cambiar con el tiempo
    
- incluso sin nuevas entradas
    

Ejemplo:

- replicación
    
- reconciliación
    

---

### E4.4 Eventual Consistency

> **Si no hay nuevas escrituras,  
> el sistema converge a un estado consistente.**

Clave:

- **eventualmente**, no inmediatamente
    

---

### E4.5 Error típico del principiante

> “Eventual consistency es un bug.”

No:

- es una propiedad
    
- debe diseñarse
    

---

## E5. Modelos de datos NoSQL (desarmados)

---

### E5.1 Key-Value

#### Definición

> Pares clave–valor sin semántica interna.

Ventajas:

- simplicidad
    
- velocidad
    

Desventajas:

- consultas limitadas
    

Ejemplos de uso:

- sesiones
    
- caché
    
- flags
    

---

### E5.2 Document Stores

#### Definición

> Documentos semi-estructurados (JSON-like).

Ventajas:

- flexibilidad
    
- evolución del esquema
    

Desventajas:

- joins complejos
    
- duplicación
    

Uso típico:

- catálogos
    
- perfiles
    
- contenido
    

---

### E5.3 Column-Family

#### Definición

> Almacenamiento por columnas distribuidas.

Ventajas:

- alto throughput
    
- escalabilidad masiva
    

Desventajas:

- diseño complejo
    
- consultas predefinidas
    

Uso:

- telemetría
    
- time-series
    
- big data
    

---

### E5.4 Graph Databases

#### Definición

> Datos como nodos y relaciones.

Ventajas:

- relaciones complejas
    
- traversal eficiente
    

Desventajas:

- escalado particular
    
- uso específico
    

Uso:

- redes
    
- recomendaciones
    
- fraude
    

---

## E6. Consistencia en NoSQL (no es binaria)

---

### E6.1 Niveles de consistencia

Muchos sistemas NoSQL permiten:

- strong consistency
    
- eventual consistency
    
- consistencia por quorum
    

No es todo o nada.

---

### E6.2 Quorum (modelo clave)

Ejemplo conceptual:

- N réplicas
    
- W escrituras
    
- R lecturas
    

Regla:

> **Si R + W > N, se puede lograr consistencia fuerte.**

Trade-off:

- latencia
    
- disponibilidad
    

---

## E7. Antipatrones NoSQL (muy comunes)

---

### E7.1 Antipatrón: NoSQL por moda

- sin requerimiento real
    
- sin entender CAP
    
- sin diseñar consistencia
    

Resultado:

- sistema incoherente
    
- lógica compleja
    
- bugs sutiles
    

---

### E7.2 Antipatrón: Modelar como SQL

- joins inexistentes
    
- normalización forzada
    
- consultas imposibles
    

---

### E7.3 Antipatrón: Ignorar consistencia eventual

- asumir lecturas inmediatas
    
- mostrar estados incorrectos
    
- romper experiencia de usuario
    

---

## E8. Señales de comprensión real

Sabes que entiendes NoSQL cuando:

- puedes explicar por qué **no** usarlo
    
- puedes justificar el trade-off C vs A
    
- puedes diseñar para consistencia eventual
    
- puedes explicar estados intermedios al negocio
    

---

## E9. Ejercicio práctico (obligatorio)

Diseña un sistema con:

- usuarios globales
    
- alta disponibilidad
    
- tolerancia a fallos regionales
    

Define:

- tipo de base NoSQL
    
- modelo de consistencia
    
- qué se sacrifica
    
- cómo comunicas estados inconsistentes
    

---

# BLOQUE F — Pruebas avanzadas, TDD real y calidad sistémica

**Cuando testear deja de ser una tarea y se convierte en un sistema de defensa**

---

## F1. Contexto: por qué “tener tests” no garantiza calidad

En niveles iniciales, “tener pruebas” suele significar:

- algunos tests unitarios
    
- cobertura aceptable
    
- pipeline en verde
    
- sensación de seguridad
    

En nivel **ADVANCED**, esta ilusión se rompe rápido.

Porque en sistemas reales:

- los bugs aparecen **con tests**
    
- los tests pasan pero producción falla
    
- los cambios pequeños rompen cosas lejanas
    
- el miedo a tocar código crece
    

Aquí aparece una verdad incómoda:

> **Los tests no garantizan calidad.  
> Garantizan señales.**

La calidad emerge de **qué pruebas tienes, cómo están diseñadas y qué decisiones fuerzan**.

---

## F2. Definición extensa: qué es calidad en backend avanzado

Calidad **no es**:

- cobertura alta
    
- muchos tests
    
- frameworks de testing
    

Calidad es:

> **La capacidad del sistema de cambiar con confianza,  
> detectar fallos temprano y fallar de manera controlada.**

Incluye:

- corrección
    
- resiliencia
    
- observabilidad
    
- mantenibilidad
    
- previsibilidad
    

Las pruebas son un **medio**, no el fin.

---

## F3. TDD real (no el ritual superficial)

---

### F3.1 Contexto: por qué TDD se malinterpreta

TDD suele enseñarse como:

1. test rojo
    
2. código verde
    
3. refactor
    

Pero en la práctica avanzada:

- el valor no está en el orden
    
- está en **las decisiones que obliga a tomar**
    

---

### F3.2 Definición correcta de TDD

TDD es:

> **Una disciplina de diseño que utiliza pruebas para forzar claridad en responsabilidades, contratos y dependencias antes de escribir implementación.**

No es:

- escribir tests primero “porque sí”
    
- asegurar cobertura
    

---

### F3.3 Modelo mental incorrecto

> “TDD es para no tener bugs.”

No lo es.

---

### F3.4 Modelo mental correcto (ADVANCED)

> “TDD es para **diseñar mejor**,  
> los bugs son un efecto secundario.”

Un advanced usa TDD para:

- descubrir dependencias ocultas
    
- reducir acoplamiento
    
- forzar interfaces claras
    
- evitar sobreingeniería
    

---

### F3.5 Qué tipo de tests nacen naturalmente con TDD

- tests pequeños
    
- tests rápidos
    
- tests aislados
    
- tests expresivos
    

Si tus tests son:

- lentos
    
- frágiles
    
- dependientes de infraestructura
    

entonces **no estás haciendo TDD real**.

---

## F4. Pruebas unitarias profundas (más allá del “happy path”)

---

### F4.1 Qué es realmente una prueba unitaria

Una prueba unitaria verifica:

> **El comportamiento de una unidad lógica aislada,  
> bajo condiciones controladas.**

No prueba:

- frameworks
    
- bases de datos
    
- redes
    
- configuraciones externas
    

---

### F4.2 Unidad ≠ Clase

Error común:

> “Una clase = una unidad.”

Falso.

Una unidad es:

- una responsabilidad
    
- una decisión
    
- una regla
    

---

### F4.3 Errores típicos en pruebas unitarias

- mocks excesivos
    
- tests acoplados a implementación
    
- verificar detalles internos
    
- ignorar casos borde
    
- nombres poco expresivos
    

---

### F4.4 Modelo mental correcto

> “Una prueba unitaria describe **qué debe pasar**,  
> no **cómo pasa**.”

---

## F5. Pruebas de integración (donde aparecen los problemas reales)

---

### F5.1 Contexto

La mayoría de los bugs críticos aparecen:

- entre componentes
    
- entre capas
    
- entre servicios
    

No dentro de una clase aislada.

---

### F5.2 Definición

Una prueba de integración valida:

> **La colaboración correcta entre múltiples componentes reales.**

Puede incluir:

- base de datos real o embebida
    
- configuración real
    
- serialización real
    

---

### F5.3 Error común

- confundir integración con end-to-end
    
- tener demasiadas pruebas lentas
    
- usar infraestructura compartida
    

---

### F5.4 Modelo correcto

> “Integro lo mínimo necesario  
> para validar una frontera real.”

---

## F6. Pruebas de contrato (fundamentales en microservicios)

---

### F6.1 Contexto: el problema de versiones incompatibles

En sistemas distribuidos:

- productor y consumidor evolucionan
    
- se despliegan independientemente
    
- los errores no se detectan a tiempo
    

---

### F6.2 Definición

Las pruebas de contrato verifican:

> **Que un servicio cumple el contrato esperado por sus consumidores.**

No prueban:

- implementación interna
    
- lógica completa
    

Prueban:

- estructura
    
- semántica mínima
    
- compatibilidad
    

---

### F6.3 Modelo mental correcto

> “El contrato es más estable que el código.”

---

### F6.4 Error típico

- confiar solo en documentación
    
- no automatizar contratos
    
- romper compatibilidad sin saberlo
    

---

## F7. Pruebas de concurrencia y condiciones de carrera

---

### F7.1 Contexto

Los tests secuenciales:

- no detectan race conditions
    
- no revelan deadlocks
    
- no muestran starvation
    

---

### F7.2 Qué se prueba realmente

- acceso concurrente a estado
    
- idempotencia
    
- orden no garantizado
    
- reintentos
    

---

### F7.3 Error común

> “Si no falló en local, está bien.”

---

### F7.4 Modelo correcto

> “Las pruebas deben forzar escenarios patológicos.”

---

## F8. Antipatrones de testing (muy comunes)

---

### F8.1 Antipatrón: Tests frágiles

- fallan con refactors
    
- dependen de orden
    
- dependen de tiempo
    

Resultado:

- miedo a cambiar código
    

---

### F8.2 Antipatrón: Cobertura como objetivo

- tests sin valor
    
- assertions triviales
    
- falsa seguridad
    

---

### F8.3 Antipatrón: Mockear todo

- tests irreales
    
- contratos falsos
    
- bugs en producción
    

---

### F8.4 Antipatrón: Tests lentos en CI

- pipelines largos
    
- feedback tardío
    
- presión por saltarse pruebas
    

---

## F9. Observabilidad como complemento del testing

Pruebas no capturan todo.

Por eso:

- logs
    
- métricas
    
- trazas
    

Son parte de la **calidad sistémica**.

---

## F10. Señales de comprensión real

Sabes que entiendes testing avanzado cuando:

- confías en cambiar código
    
- los tests te guían
    
- detectas bugs temprano
    
- puedes explicar qué NO testear
    

---

## F11. Ejercicio integrador

Toma un sistema real y responde:

1. ¿Qué pruebas te dan confianza?
    
2. ¿Cuáles te dan falsa seguridad?
    
3. ¿Qué contratos están implícitos?
    
4. ¿Dónde aparecen bugs tarde?
    
5. ¿Qué prueba eliminarías hoy?
    

---

# BLOQUE G — Cloud, DevOps (CD), Contenedores y Caché

**De desplegar aplicaciones a operar sistemas vivos en producción**

---

## G1. Cloud Computing real (IaaS, PaaS, SaaS sin marketing)

---

### G1.1 Contexto: por qué “subir a la nube” no es arquitectura

En niveles iniciales, cloud suele verse como:

- “subir el backend a AWS/Azure/GCP”
    
- “usar un servicio administrado”
    
- “no preocuparme por servidores”
    

En nivel **ADVANCED**, esta visión es peligrosa.

Porque:

- la nube **no elimina complejidad**
    
- solo **la traslada**
    
- y muchas veces **la amplifica**
    

Verdad clave:

> **La nube no diseña por ti;  
> solo te da primitives más rápidas de consumir.**

---

### G1.2 Definición extensa: qué es realmente Cloud Computing

Cloud Computing es:

> **Un modelo de provisión de recursos computacionales bajo demanda, con elasticidad, pago por uso y abstracción progresiva de la infraestructura física.**

Desarmando la definición:

- **Provisión bajo demanda**  
    Recursos cuando los necesitas.
    
- **Elasticidad**  
    Escalar hacia arriba y abajo.
    
- **Pago por uso**  
    El costo es una señal arquitectónica.
    
- **Abstracción progresiva**  
    Menos control → menos responsabilidad (pero no cero).
    

---

### G1.3 IaaS (Infrastructure as a Service)

#### Definición

IaaS ofrece:

- máquinas virtuales
    
- redes
    
- discos
    
- balanceadores básicos
    

Tú sigues siendo responsable de:

- SO
    
- parches
    
- seguridad
    
- escalado
    

---

#### Cuándo usar IaaS

- control fino requerido
    
- workloads especiales
    
- migraciones legacy
    

---

#### Error común

> “IaaS = no me preocupo.”

Falso:

> **Eres responsable de casi todo.**

---

### G1.4 PaaS (Platform as a Service)

#### Definición

PaaS abstrae:

- SO
    
- runtime
    
- parches
    
- escalado básico
    

Tú te enfocas en:

- código
    
- configuración
    
- límites del servicio
    

---

#### Trade-off real

Menos control  
a cambio de  
menos carga operativa.

---

### G1.5 SaaS (Software as a Service)

#### Definición

SaaS ofrece:

- funcionalidad completa
    
- mínima operación
    

Ejemplos:

- Auth
    
- Email
    
- Observabilidad
    
- CRM
    

---

#### Riesgo real

- dependencia del proveedor
    
- lock-in
    
- límites ocultos
    

---

### G1.6 Modelo mental correcto (ADVANCED)

> “Elijo el modelo de cloud  
> según **responsabilidad aceptable**,  
> no según comodidad.”

---

## G2. DevOps y Continuous Delivery (CD) real

---

### G2.1 Contexto: por qué CD no es solo pipeline verde

En niveles bajos:

- “CI/CD = pipeline que despliega”
    

En **ADVANCED**, CD significa:

> **Capacidad de poner cambios en producción de forma segura, frecuente y reversible.**

---

### G2.2 Definición de Continuous Delivery

CD es:

> **Una disciplina que asegura que el sistema está siempre en un estado desplegable, con mecanismos para desplegar, validar y revertir cambios rápidamente.**

---

### G2.3 Componentes reales de CD

- control de versiones
    
- build reproducible
    
- tests automatizados
    
- artefactos versionados
    
- despliegue automatizado
    
- rollback
    
- observabilidad post-deploy
    

Si falta uno:

> **No hay CD real.**

---

### G2.4 Error común

> “Si pasa el pipeline, está bien.”

Falso:

- el pipeline valida supuestos
    
- no la realidad completa
    

---

### G2.5 Modelo mental correcto

> “El despliegue es el inicio del feedback,  
> no el final.”

---

## G3. Contenedores: Docker desarmado de verdad

---

### G3.1 Contexto: por qué Docker cambia el juego

Antes de Docker:

- entornos inconsistentes
    
- “en mi máquina funciona”
    
- despliegues frágiles
    

Docker aparece para:

- empaquetar runtime + app
    
- estandarizar despliegues
    
- reducir sorpresas
    

---

### G3.2 Qué es realmente un contenedor

Un contenedor es:

> **Un proceso aislado que comparte el kernel del host, con su propio filesystem, red y límites de recursos.**

No es:

- una VM
    
- un servidor
    

---

### G3.3 Modelo mental incorrecto

> “Un contenedor es una mini VM.”

Esto lleva a:

- imágenes gigantes
    
- servicios monolíticos
    
- mala performance
    

---

### G3.4 Modelo mental correcto (ADVANCED)

> “Un contenedor es un **proceso bien encapsulado**.”

---

### G3.5 Errores típicos con Docker

- imágenes grandes
    
- múltiples procesos por contenedor
    
- secretos dentro de la imagen
    
- no definir límites de recursos
    

---

### G3.6 Ejercicio práctico

Audita una imagen Docker y responde:

- tamaño
    
- procesos
    
- dependencias innecesarias
    
- secretos
    

---

## G4. Orquestación: Kubernetes (K8s) sin mitos

---

### G4.1 Contexto: por qué Docker no es suficiente

Con un contenedor:

- todo bien
    

Con 100:

- caos
    

Aparece la necesidad de:

- scheduling
    
- escalado
    
- networking
    
- autorecuperación
    

---

### G4.2 Qué es Kubernetes realmente

Kubernetes es:

> **Un sistema de orquestación que gestiona el ciclo de vida de contenedores declarativamente.**

No:

- un framework
    
- un runtime
    
- una solución mágica
    

---

### G4.3 Componentes clave (conceptuales)

- Pods
    
- Services
    
- Deployments
    
- ConfigMaps
    
- Secrets
    

Cada uno define **intención**, no acción inmediata.

---

### G4.4 Error común

> “Kubernetes arregla mis problemas.”

No:

> **Kubernetes amplifica decisiones malas.**

---

### G4.5 Modelo mental correcto

> “Kubernetes ejecuta lo que declaro,  
> no lo que deseo.”

---

## G5. Caché distribuida (Redis, Memcached) sin abusos

---

### G5.1 Contexto: por qué la caché es inevitable

En sistemas grandes:

- la BD no escala sola
    
- la latencia importa
    
- repetir cálculos es caro
    

Aparece la caché como:

- optimización
    
- amortiguador
    
- protección
    

---

### G5.2 Qué es caché realmente

Caché es:

> **Un almacenamiento temporal que prioriza velocidad sobre durabilidad y consistencia.**

No es:

- fuente de verdad
    
- base de datos alternativa
    

---

### G5.3 Modelos comunes de caché

- read-through
    
- write-through
    
- write-back
    
- cache-aside
    

Cada uno con trade-offs.

---

### G5.4 Antipatrones de caché

- caché sin invalidación
    
- caché de datos críticos
    
- TTL arbitrarios
    
- dependencia fuerte
    

---

### G5.5 Modelo mental correcto

> “La caché es un **acelerador**,  
> no un pilar.”

---

## G6. Antipatrones Cloud / DevOps (los que cuestan dinero y tiempo)

---

### G6.1 Antipatrón: Escalar sin medir

- costos impredecibles
    
- recursos desperdiciados
    

---

### G6.2 Antipatrón: Secretos en código o imágenes

- brechas graves
    
- rotación imposible
    

---

### G6.3 Antipatrón: Kubernetes por moda

- complejidad innecesaria
    
- curva de aprendizaje alta
    

---

### G6.4 Antipatrón: Caché como solución universal

- inconsistencias
    
- bugs sutiles
    
- lógica duplicada
    

---

## G7. Señales de comprensión real

Sabes que entiendes este bloque cuando:

- puedes explicar costos
    
- puedes revertir despliegues
    
- puedes justificar K8s o no usarlo
    
- sabes cuándo cachear
    
- puedes operar el sistema bajo fallos
    

---

## G8. Ejercicio integrador final

Diseña un sistema completo y responde:

1. ¿Qué corre en IaaS, PaaS o SaaS?
    
2. ¿Cómo despliegas sin downtime?
    
3. ¿Cómo haces rollback?
    
4. ¿Qué se cachea y qué no?
    
5. ¿Qué pasa si un nodo cae?
    
6. ¿Qué monitoreas primero?
    

---

## CIERRE DEL NIVEL ADVANCED (sin resumen)

Hasta aquí se han cubierto **todos los bloques del nivel ADVANCED**:

- Protocolos avanzados
    
- Framework y seguridad profunda
    
- SQL/RDBMS avanzado
    
- Concurrencia real
    
- NoSQL, CAP y BASE
    
- Testing avanzado
    
- Cloud, DevOps, contenedores y caché
    

Cuando tú lo indiques, puedo:

- iniciar **NIVEL: SENIOR**
    
- convertir esto en **mapa de estudio**
    
- generar **checklists de dominio**
    
- crear **evaluaciones técnicas**
    
- o **bajar un bloque a código real**
    

Tú mandas.
